/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2011,2013-2014,2016-2018,2020 Roger L. Whitcomb.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 *	Various static methods for numeric conversions and manipulations.
 *
 *  History:
 *	23-Feb-2011 (rlwhitcomb)
 *	    Created.
 *	11-Mar-2013 (rlwhitcomb)
 *	    Create static methods to determine the appropriate size
 *	    range for a (possibly) large value, and then to format it
 *	    into that range.
 *	21-Aug-2013 (rlwhitcomb)
 *	    Really support Terabytes and Petabytes in the value match pattern
 *	    but still only support KMG value range in that method.
 *	04-Oct-2013 (rlwhitcomb)
 *	    Add method to convert a long to human-readable words.
 *	06-Nov-2014 (rlwhitcomb)
 *	    Move error message strings to resource bundle.  Not quite ready to do
 *	    the same for the number names.
 *	20-Nov-2014 (rlwhitcomb)
 *	    Make a new method to format big numbers using short suffixes (space-constrained).
 *	05-Jan-2016 (rlwhitcomb)
 *	    After writing tests for "convertToWords" it was discovered that it fails for
 *	    Long.MAX_VALUE, so redo the logic to fix that.
 *	07-Jan-2016 (rlwhitcomb)
 *	    Finally getting to fixing the Java 8 Javadoc warnings.
 *	12-Apr-2016 (rlwhitcomb)
 *	    Methods to convert to/from BCD format and BigDecimal.
 *	22-Aug-2017 (rlwhitcomb)
 *	    Method to round up to a power of two.
 *	12-Feb-2018 (rlwhitcomb)
 *	    More methods to deal with binary files.
 *	14-Feb-2018 (rlwhitcomb)
 *	    Implement RAW binary file read support.
 *	07-May-2018 (rlwhitcomb)
 *	    Fix BCD support a little bit, implement raw writing.
 *	10-Aug-2018 (rlwhitcomb)
 *	    Add method to do exponentiation on BigDecimal values.
 *	29-Jan-2020 (rlwhitcomb)
 *	    Add BigInteger ("bigint") support.
 *	10-Mar-2020 (rlwhitcomb)
 *	    Prepare for GitHub.
 *	02-Dec-2020 (rlwhitcomb)
 *	    Add "constants" for PI and E to arbitrary (well, under 10,000) digits
 *	    (as BigDecimal).
 */
package info.rlwhitcomb.util;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.EOFException;
import java.io.IOException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.nio.charset.Charset;
import java.util.Arrays;
import java.util.Date;
import java.util.regex.*;


/**
 * Collection of static methods to deal with numeric conversions.
 * <p> NOTE: this class will (somewhat confusingly) deal with conversions
 * to binary units instead of SI units to go along with historical usage
 * in the computer industry.  This differs from the units used by disk-drive
 * manufacturers (for instance) which specify sizes in SI (decimal) units.
 */
public class NumericUtil
{
	/**
	 * Enum representing the binary data types.
	 */
	public static enum DataType
	{
	    NUL   (0),
	    BYTE  (1),
	    SHORT (2),
	    INT   (3),
	    LONG  (4),
	    DEC   (5),
	    FLOAT (6),
	    DOUBLE(7),
	    DATE  (8),
	    CHAR  (9),
	    STRING(10),
	    BIGINT(11);

	    private int idCode;

	    private DataType(int code) {
		this.idCode = code;
	    }

	    public int getCode() {
		return this.idCode;
	    }

	    public static DataType fromCode(int code) {
		// This relies on the code being the same as the ordinal
		DataType[] values = values();
		if (code < 0 || code >= values.length) {
		    throw new IllegalArgumentException(Intl.formatString("util#numeric.badDataTypeCode", code));
		}
		return values[code];
	    }
	}


	/**
	 * Byte order for raw binary numeric values.
	 */
	public static enum ByteOrder
	{
		LSB,
		MSB;

		public static ByteOrder fromString(String value) {
		    for (ByteOrder order : values()) {
			if (order.toString().equals(value.toUpperCase())) {
			    return order;
			}
		    }
		    throw new IllegalArgumentException(Intl.formatString("util#numeric.unknownByteOrder", value));
		}
	}


	/**
	 * Determines how strings are to be read/written to raw binary files.
	 */
	public static enum StringLength
	{
		/** Byte width specified at read/write time, padded with 0x00 bytes. */
		FIXED,
		/** String delimited by 0x00 byte at the end. */
		EOS,
		/** String length prefix (one byte, max 255 bytes). */
		PREFIX1,
		/** String length prefix (two bytes, max 32767 bytes). */
		PREFIX2,
		/** String length prefix (four bytes, max 4,294,967,295 bytes). */
		PREFIX4;

		public static StringLength fromString(String value) {
		    for (StringLength length : values()) {
			if (length.toString().equals(value.toUpperCase())) {
			    return length;
			}
		    }
		    throw new IllegalArgumentException(Intl.formatString("util#numeric.unknownStringLength", value));
		}
	}

	/**
	 * The first 10,000 digits of PI (generated by code from
	 * <a href="http://www.codecodex.com/wiki/index.php?title=Digits_of_pi_calculation#Java">
         * http://www.codecodex.com/wiki/index.php?title=Digits_of_pi_calculation#Java</a>).
         */
	public static final String PI_DIGITS =
		"3." +
		"14159265358979323846264338327950288419716939937510582097494459230781640628620899" +
		"86280348253421170679821480865132823066470938446095505822317253594081284811174502" +
		"84102701938521105559644622948954930381964428810975665933446128475648233786783165" +
		"27120190914564856692346034861045432664821339360726024914127372458700660631558817" +
		"48815209209628292540917153643678925903600113305305488204665213841469519415116094" +
		"33057270365759591953092186117381932611793105118548074462379962749567351885752724" +
		"89122793818301194912983367336244065664308602139494639522473719070217986094370277" +
		"05392171762931767523846748184676694051320005681271452635608277857713427577896091" +
		"73637178721468440901224953430146549585371050792279689258923542019956112129021960" +
		"86403441815981362977477130996051870721134999999837297804995105973173281609631859" +
		"50244594553469083026425223082533446850352619311881710100031378387528865875332083" +
		"81420617177669147303598253490428755468731159562863882353787593751957781857780532" +
		"17122680661300192787661119590921642019893809525720106548586327886593615338182796" +
		"82303019520353018529689957736225994138912497217752834791315155748572424541506959" +
		"50829533116861727855889075098381754637464939319255060400927701671139009848824012" +
		"85836160356370766010471018194295559619894676783744944825537977472684710404753464" +
		"62080466842590694912933136770289891521047521620569660240580381501935112533824300" +
		"35587640247496473263914199272604269922796782354781636009341721641219924586315030" +
		"28618297455570674983850549458858692699569092721079750930295532116534498720275596" +
		"02364806654991198818347977535663698074265425278625518184175746728909777727938000" +
		"81647060016145249192173217214772350141441973568548161361157352552133475741849468" +
		"43852332390739414333454776241686251898356948556209921922218427255025425688767179" +
		"04946016534668049886272327917860857843838279679766814541009538837863609506800642" +
		"25125205117392984896084128488626945604241965285022210661186306744278622039194945" +
		"04712371378696095636437191728746776465757396241389086583264599581339047802759009" +
		"94657640789512694683983525957098258226205224894077267194782684826014769909026401" +
		"36394437455305068203496252451749399651431429809190659250937221696461515709858387" +
		"41059788595977297549893016175392846813826868386894277415599185592524595395943104" +
		"99725246808459872736446958486538367362226260991246080512438843904512441365497627" +
		"80797715691435997700129616089441694868555848406353422072225828488648158456028506" +
		"01684273945226746767889525213852254995466672782398645659611635488623057745649803" +
		"55936345681743241125150760694794510965960940252288797108931456691368672287489405" +
		"60101503308617928680920874760917824938589009714909675985261365549781893129784821" +
		"68299894872265880485756401427047755513237964145152374623436454285844479526586782" +
		"10511413547357395231134271661021359695362314429524849371871101457654035902799344" +
		"03742007310578539062198387447808478489683321445713868751943506430218453191048481" +
		"00537061468067491927819119793995206141966342875444064374512371819217999839101591" +
		"95618146751426912397489409071864942319615679452080951465502252316038819301420937" +
		"62137855956638937787083039069792077346722182562599661501421503068038447734549202" +
		"60541466592520149744285073251866600213243408819071048633173464965145390579626856" +
		"10055081066587969981635747363840525714591028970641401109712062804390397595156771" +
		"57700420337869936007230558763176359421873125147120532928191826186125867321579198" +
		"41484882916447060957527069572209175671167229109816909152801735067127485832228718" +
		"35209353965725121083579151369882091444210067510334671103141267111369908658516398" +
		"31501970165151168517143765761835155650884909989859982387345528331635507647918535" +
		"89322618548963213293308985706420467525907091548141654985946163718027098199430992" +
		"44889575712828905923233260972997120844335732654893823911932597463667305836041428" +
		"13883032038249037589852437441702913276561809377344403070746921120191302033038019" +
		"76211011004492932151608424448596376698389522868478312355265821314495768572624334" +
		"41893039686426243410773226978028073189154411010446823252716201052652272111660396" +
		"66557309254711055785376346682065310989652691862056476931257058635662018558100729" +
		"36065987648611791045334885034611365768675324944166803962657978771855608455296541" +
		"26654085306143444318586769751456614068007002378776591344017127494704205622305389" +
		"94561314071127000407854733269939081454664645880797270826683063432858785698305235" +
		"80893306575740679545716377525420211495576158140025012622859413021647155097925923" +
		"09907965473761255176567513575178296664547791745011299614890304639947132962107340" +
		"43751895735961458901938971311179042978285647503203198691514028708085990480109412" +
		"14722131794764777262241425485454033215718530614228813758504306332175182979866223" +
		"71721591607716692547487389866549494501146540628433663937900397692656721463853067" +
		"36096571209180763832716641627488880078692560290228472104031721186082041900042296" +
		"61711963779213375751149595015660496318629472654736425230817703675159067350235072" +
		"83540567040386743513622224771589150495309844489333096340878076932599397805419341" +
		"44737744184263129860809988868741326047215695162396586457302163159819319516735381" +
		"29741677294786724229246543668009806769282382806899640048243540370141631496589794" +
		"09243237896907069779422362508221688957383798623001593776471651228935786015881617" +
		"55782973523344604281512627203734314653197777416031990665541876397929334419521541" +
		"34189948544473456738316249934191318148092777710386387734317720754565453220777092" +
		"12019051660962804909263601975988281613323166636528619326686336062735676303544776" +
		"28035045077723554710585954870279081435624014517180624643626794561275318134078330" +
		"33625423278394497538243720583531147711992606381334677687969597030983391307710987" +
		"04085913374641442822772634659470474587847787201927715280731767907707157213444730" +
		"60570073349243693113835049316312840425121925651798069411352801314701304781643788" +
		"51852909285452011658393419656213491434159562586586557055269049652098580338507224" +
		"26482939728584783163057777560688876446248246857926039535277348030480290058760758" +
		"25104747091643961362676044925627420420832085661190625454337213153595845068772460" +
		"29016187667952406163425225771954291629919306455377991403734043287526288896399587" +
		"94757291746426357455254079091451357111369410911939325191076020825202618798531887" +
		"70584297259167781314969900901921169717372784768472686084900337702424291651300500" +
		"51683233643503895170298939223345172201381280696501178440874519601212285993716231" +
		"30171144484640903890644954440061986907548516026327505298349187407866808818338510" +
		"22833450850486082503930213321971551843063545500766828294930413776552793975175461" +
		"39539846833936383047461199665385815384205685338621867252334028308711232827892125" +
		"07712629463229563989898935821167456270102183564622013496715188190973038119800497" +
		"34072396103685406643193950979019069963955245300545058068550195673022921913933918" +
		"56803449039820595510022635353619204199474553859381023439554495977837790237421617" +
		"27111723643435439478221818528624085140066604433258885698670543154706965747458550" +
		"33232334210730154594051655379068662733379958511562578432298827372319898757141595" +
		"78111963583300594087306812160287649628674460477464915995054973742562690104903778" +
		"19868359381465741268049256487985561453723478673303904688383436346553794986419270" +
		"56387293174872332083760112302991136793862708943879936201629515413371424892830722" +
		"01269014754668476535761647737946752004907571555278196536213239264061601363581559" +
		"07422020203187277605277219005561484255518792530343513984425322341576233610642506" +
		"39049750086562710953591946589751413103482276930624743536325691607815478181152843" +
		"66795706110861533150445212747392454494542368288606134084148637767009612071512491" +
		"40430272538607648236341433462351897576645216413767969031495019108575984423919862" +
		"91642193994907236234646844117394032659184044378051333894525742399508296591228508" +
		"55582157250310712570126683024029295252201187267675622041542051618416348475651699" +
		"98116141010029960783869092916030288400269104140792886215078424516709087000699282" +
		"12066041837180653556725253256753286129104248776182582976515795984703562226293486" +
		"00341587229805349896502262917487882027342092222453398562647669149055628425039127" +
		"57710284027998066365825488926488025456610172967026640765590429099456815065265305" +
		"37182941270336931378517860904070866711496558343434769338578171138645587367812301" +
		"45876871266034891390956200993936103102916161528813843790990423174733639480457593" +
		"14931405297634757481193567091101377517210080315590248530906692037671922033229094" +
		"33467685142214477379393751703443661991040337511173547191855046449026365512816228" +
		"82446257591633303910722538374218214088350865739177150968288747826569959957449066" +
		"17583441375223970968340800535598491754173818839994469748676265516582765848358845" +
		"31427756879002909517028352971634456212964043523117600665101241200659755851276178" +
		"58382920419748442360800719304576189323492292796501987518721272675079812554709589" +
		"04556357921221033346697499235630254947802490114195212382815309114079073860251522" +
		"74299581807247162591668545133312394804947079119153267343028244186041426363954800" +
		"04480026704962482017928964766975831832713142517029692348896276684403232609275249" +
		"60357996469256504936818360900323809293459588970695365349406034021665443755890045" +
		"63288225054525564056448246515187547119621844396582533754388569094113031509526179" +
		"37800297412076651479394259029896959469955657612186561967337862362561252163208628" +
		"69222103274889218654364802296780705765615144632046927906821207388377814233562823" +
		"60896320806822246801224826117718589638140918390367367222088832151375560037279839" +
		"40041529700287830766709444745601345564172543709069793961225714298946715435784687" +
		"88614445812314593571984922528471605049221242470141214780573455105008019086996033" +
		"02763478708108175450119307141223390866393833952942578690507643100638351983438934" +
		"15961318543475464955697810382930971646514384070070736041123735998434522516105070" +
		"27056235266012764848308407611830130527932054274628654036036745328651057065874882" +
		"25698157936789766974220575059683440869735020141020672358502007245225632651341055" +
		"92401902742162484391403599895353945909440704691209140938700126456001623742880210" +
		"92764579310657922955249887275846101264836999892256959688159205600101655256375678";

	/**
	 * The first 10,000 digits of E (generated by EulerSpigot.go from:
         * <a href="https://github.com/zachratliff22/EulerSpigot/blob/master/EulerSpigot.go">here</a>).
	 */
	public static final String E_DIGITS =
		"2." +
		"71828182845904523536028747135266249775724709369995957496696762772407663035354759" +
		"45713821785251664274274663919320030599218174135966290435729003342952605956307381" +
		"32328627943490763233829880753195251019011573834187930702154089149934884167509244" +
		"76146066808226480016847741185374234544243710753907774499206955170276183860626133" +
		"13845830007520449338265602976067371132007093287091274437470472306969772093101416" +
		"92836819025515108657463772111252389784425056953696770785449969967946864454905987" +
		"93163688923009879312773617821542499922957635148220826989519366803318252886939849" +
		"64651058209392398294887933203625094431173012381970684161403970198376793206832823" +
		"76464804295311802328782509819455815301756717361332069811250996181881593041690351" +
		"59888851934580727386673858942287922849989208680582574927961048419844436346324496" +
		"84875602336248270419786232090021609902353043699418491463140934317381436405462531" +
		"52096183690888707016768396424378140592714563549061303107208510383750510115747704" +
		"17189861068739696552126715468895703503540212340784981933432106817012100562788023" +
		"51930332247450158539047304199577770935036604169973297250886876966403555707162268" +
		"44716256079882651787134195124665201030592123667719432527867539855894489697096409" +
		"75459185695638023637016211204774272283648961342251644507818244235294863637214174" +
		"02388934412479635743702637552944483379980161254922785092577825620926226483262779" +
		"33386566481627725164019105900491644998289315056604725802778631864155195653244258" +
		"69829469593080191529872117255634754639644791014590409058629849679128740687050489" +
		"58586717479854667757573205681288459205413340539220001137863009455606881667400169" +
		"84205580403363795376452030402432256613527836951177883863874439662532249850654995" +
		"88623428189970773327617178392803494650143455889707194258639877275471096295374152" +
		"11151368350627526023264847287039207643100595841166120545297030236472549296669381" +
		"15137322753645098889031360205724817658511806303644281231496550704751025446501172" +
		"72115551948668508003685322818315219600373562527944951582841882947876108526398139" +
		"55990067376482922443752871846245780361929819713991475644882626039033814418232625" +
		"15097482798777996437308997038886778227138360577297882412561190717663946507063304" +
		"52795466185509666618566470971134447401607046262156807174818778443714369882185596" +
		"70959102596862002353718588748569652200050311734392073211390803293634479727355955" +
		"27734907178379342163701205005451326383544000186323991490705479778056697853358048" +
		"96690629511943247309958765523681285904138324116072260299833053537087613893963917" +
		"79574540161372236187893652605381558415871869255386061647798340254351284396129460" +
		"35291332594279490433729908573158029095863138268329147711639633709240031689458636" +
		"06064584592512699465572483918656420975268508230754425459937691704197778008536273" +
		"09417101634349076964237222943523661255725088147792231519747780605696725380171807" +
		"76360346245927877846585065605078084421152969752189087401966090665180351650179250" +
		"46195013665854366327125496399085491442000145747608193022120660243300964127048943" +
		"90397177195180699086998606636583232278709376502260149291011517177635944602023249" +
		"30028040186772391028809786660565118326004368850881715723866984224220102495055188" +
		"16948032210025154264946398128736776589276881635983124778865201411741109136011649" +
		"95076629077943646005851941998560162647907615321038727557126992518275687989302761" +
		"76114616254935649590379804583818232336861201624373656984670378585330527583333793" +
		"99075216606923805336988795651372855938834998947074161815501253970646481719467083" +
		"48197214488898790676503795903669672494992545279033729636162658976039498576741397" +
		"35944102374432970935547798262961459144293645142861715858733974679189757121195618" +
		"73857836447584484235555810500256114923915188930994634284139360803830916628188115" +
		"03715284967059741625628236092168075150177725387402564253470879089137291722828611" +
		"51591568372524163077225440633787593105982676094420326192428531701878177296023541" +
		"30606721360460003896610936470951414171857770141806064436368154644400533160877831" +
		"43174440811949422975599314011888683314832802706553833004693290115744147563139997" +
		"22170380461709289457909627166226074071874997535921275608441473782330327033016823" +
		"71936480021732857349359475643341299430248502357322145978432826414216848787216733" +
		"67010615094243456984401873312810107945127223737886126058165668053714396127888732" +
		"52737389039289050686532413806279602593038772769778379286840932536588073398845721" +
		"87460210053114833513238500478271693762180049047955979592905916554705057775143081" +
		"75112698985188408718564026035305583737832422924185625644255022672155980274012617" +
		"97192804713960068916382866527700975276706977703643926022437284184088325184877047" +
		"26384403795301669054659374616193238403638931313643271376888410268112198912752230" +
		"56256756254701725086349765367288605966752740868627407912856576996313789753034660" +
		"61666980421826772456053066077389962421834085988207186468262321508028828635974683" +
		"96543588566855037731312965879758105012149162076567699506597153447634703208532156" +
		"03674828608378656803073062657633469774295634643716709397193060876963495328846833" +
		"61303882943104080029687386911706666614680001512114344225602387447432525076938707" +
		"77751932999421372772112588436087158348356269616619805725266122067975406210620806" +
		"49882918454395301529982092503005498257043390553570168653120526495614857249257386" +
		"20691740369521353373253166634546658859728665945113644137033139367211856955395210" +
		"84584072443238355860631068069649248512326326995146035960372972531983684233639046" +
		"32136710116192821711150282801604488058802382031981493096369596735832742024988245" +
		"68494127386056649135252670604623445054922758115170931492187959271800194096886698" +
		"68370373022004753143381810927080300172059355305207007060722339994639905713115870" +
		"99635777359027196285061146514837526209565346713290025994397663114545902685898979" +
		"11583709341937044115512192011716488056694593813118384376562062784631049034629395" +
		"00294583411648241149697583260118007316994373935069662957124102732391387417549230" +
		"71862454543222039552735295240245903805744502892246886285336542213815722131163288" +
		"11205214648980518009202471939171055539011394331668151582884368760696110250517100" +
		"73927623855533862725535388309606716446623709226468096712540618695021431762116681" +
		"40097595281493907222601112681153108387317617323235263605838173151034595736538223" +
		"53499293582283685100781088463434998351840445170427018938199424341009057537625776" +
		"75711180900881641833192019626234162881665213747173254777277834887743665188287521" +
		"56685719506371936565390389449366421764003121527870222366463635755503565576948886" +
		"54950027085392361710550213114741374410613444554419210133617299628569489919336918" +
		"47294785807291560885103967819594298331864807560836795514966364489655929481878517" +
		"84038773326247051945050419847742014183947731202815886845707290544057510601285258" +
		"05659470304683634459265255213700806875200959345360731622611872817392807462309468" +
		"53678231060979215993600199462379934342106878134973469592464697525062469586169091" +
		"78573976595199392993995567542714654910456860702099012606818704984178079173924071" +
		"94599632306025470790177452751318680998228473086076653686685551646770291133682756" +
		"31072233467261137054907953658345386371962358563126183871567741187385277229225947" +
		"43373785695538456246801013905727871016512966636764451872465653730402443684140814" +
		"48873295784734849000301947788802046032466084287535184836495919508288832320652212" +
		"81041904480472479492913422849519700226013104300624107179715027934332634079959605" +
		"31446053230488528972917659876016667811937932372453857209607582277178483361613582" +
		"61289622611812945592746276713779448758675365754486140761193112595851265575973457" +
		"30153336426307679854433857617153334623252705720053039882894990342595662329757824" +
		"88735029259166825894456894655992658454762694528780516501720674785417887982276806" +
		"53665064191097343452887833862172615626958265447820567298775642632532159429441803" +
		"99432170000905426507630955884658951717091476074371368933194690909819045012903070" +
		"99566226620303182649365733698419555776963787624918852865686607600566025605445711" +
		"33728684020557441603083705231224258722343885412317948138855007568938112493538631" +
		"86352870837998456926199817945233640874295911807474534195514203517261842008455091" +
		"70845682368200897739455842679214273477560879644279202708312150156406341341617166" +
		"44806981548376449157390012121704154787259199894382536495051477137939914720521952" +
		"90793961376211072384942906163576045962312535060685376514231153496656837151166042" +
		"20796394466621163255157729070978473156278277598788136491951257483328793771571459" +
		"09106484164267830994972367442017586226940215940792448054125536043131799269673915" +
		"75424192966073123937635421392306178767539587114361040894099660894714183406983629" +
		"93675362621545247298464213752891079884381306095552622720837518629837066787224430" +
		"19579379378607210725427728907173285487437435578196651171661833088112912024520404" +
		"86822000723440350254482028342541878846536025915064452716577000445210977355858976" +
		"22655484941621714989532383421600114062950718490427789258552743035221396835679018" +
		"07640604213830730877446017084268827226117718084266433365178000217190344923426426" +
		"62922614560043373838683355553434530042648184739892156270860956506293404052649432" +
		"44261445665921291225648893569655009154306426134252668472594914314239398845432486" +
		"32746184284665598533231221046625989014171210344608427161661900125719587079321756" +
		"96985440133976220967494541854071184464339469901626983516078489245140589409463952" +
		"67807354579700307051163682519487701189764002827648414160587206184185297189154019" +
		"68825328930914966534575357142731848201638464483249903788606900807270932767312758" +
		"19665639411489617168329804551397295066876047409154204284299935410258291135022416" +
		"90769431668574242522509026939034814856451303069925199590436384028429267412573422" +
		"44776558417788617173726546208549829449894678735092958165263207225899236876845701" +
		"78230380965678831122893058091405726108658848458731016581511675333276748870148291" +
		"67419701512559782572707406431808601428149024146780472327597684269633935773542930" +
		"18673943971638861176420900406866339885684168100387238921448317607011668450388721" +
		"23643670433140911557332801829779887365909166596124020217785588548761761619893707" +
		"94380056663364884365089144805571039765214696027662583599051987042300179465536788";

	public static final BigInteger MIN_BYTE = BigInteger.valueOf(Byte.MIN_VALUE);
	public static final BigInteger MAX_BYTE = BigInteger.valueOf(Byte.MAX_VALUE);
	public static final BigInteger MIN_SHORT = BigInteger.valueOf(Short.MIN_VALUE);
	public static final BigInteger MAX_SHORT = BigInteger.valueOf(Short.MAX_VALUE);
	public static final BigInteger MIN_INT = BigInteger.valueOf(Integer.MIN_VALUE);
	public static final BigInteger MAX_INT = BigInteger.valueOf(Integer.MAX_VALUE);
	public static final BigInteger MIN_LONG = BigInteger.valueOf(Long.MIN_VALUE);
	public static final BigInteger MAX_LONG = BigInteger.valueOf(Long.MAX_VALUE);

	private static final Pattern valueMatch = Pattern.compile("^([0-9]+)([kKmMgGtTpP])$");

	private static final long MULT_KB = 1024L;
	private static final long MULT_MB = MULT_KB * MULT_KB;
	private static final long MULT_GB = MULT_MB * MULT_KB;
	private static final long MULT_TB = MULT_GB * MULT_KB;
	private static final long MULT_PB = MULT_TB * MULT_KB;

	private static final String[] smallWords = {
		"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine",
		"ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen",
		"eighteen", "nineteen"
	};
	private static final String[] tensWords = {
		"twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"
	};
	private static final long[] rangeValues = {
		 99L,  999L,  999999L,  999999999L,  999999999999L,  999999999999999L,  999999999999999999L, Long.MAX_VALUE
	};
	private static final String[] rangeWords = {
		"hundred", "thousand", "million", "billion", "trillion", "quadrillion", "quintillion"
	};
	private static final String minus = "minus";

	/**
	 * Enum to represent the range of a numeric number of bytes.
	 */
	public static enum Range
	{
		BYTES		(1L, "", "bytes", "Bytes"),
		KILOBYTES	(MULT_KB, "K", "Kbytes", "Kilobytes"),
		MEGABYTES	(MULT_MB, "M", "Mbytes", "Megabytes"),
		GIGABYTES	(MULT_GB, "G", "Gbytes", "Gigabytes"),
		TERABYTES	(MULT_TB, "T", "Tbytes", "Terabytes"),
		PETABYTES	(MULT_PB, "P", "Pbytes", "Petabytes");

		private long multiplier;
		private String prefix;
		private String shortName;
		private String longName;

		private Range(long multiplier, String prefix, String shortName, String longName) {
		    this.multiplier = multiplier;
		    this.prefix = prefix;
		    this.shortName = shortName;
		    this.longName = longName;
		}

		/** @return This "binary" multiplier where 1K == 1024 (2^10) and 1M == 1024 * 1024 (2^20),
		 * as opposed to the SI definition of the "kilo" and "mega" prefixes which are in terms
		 * of powers of 10 (i.e., 10^3, 10^6, etc.).
		 */
		public long getMultiplier() {
		    return this.multiplier;
		}

		public String getPrefix() {
		    return this.prefix;
		}

		public String getShortName() {
		    return this.shortName;
		}

		public String getLongName() {
		    return this.longName;
		}

		/**
		 * @return A {@link Range} value that corresponds to the given prefix (as in, "K", "M", etc).
		 * @param prefix The prefix to look up.
		 */
		public static Range getRangeByPrefix(String prefix) {
		    for (Range r : values()) {
			if (r.prefix.equalsIgnoreCase(prefix))
			    return r;
		    }
		    return null;
		}

		/** @return A {@link Range} value that best represents the given value.
		 * This will result in a formatted value in the range of 0.80 .. 799.99.
		 * @param value The candidate value.
		 */
		public static Range getRangeOfValue(long value) {
		    long absValue = Math.abs(value);
		    if (absValue <= 1L)
			return BYTES;
		    for (Range r : values()) {
			if (absValue / r.multiplier < 800)
			    return r;
		    }
		    return BYTES;
		}

	}


	/**
	 * Helper function to convert a "nnK" or "nnM" or "nnG" to a straight number.
	 *
	 * @param	input	The input value in one of the above formats.
	 * @return		The output as a strictly numeric value, where "nn" is
	 *			multiplied by 1024 for "K", 1024 * 1024 for "M" and
	 *			1024 * 1024 * 1024 for "G".
	 * @throws		NumberFormatException for bad input formats
	 */
	public static long convertKMGValue(String input) {
	    Matcher m = valueMatch.matcher(input);
	    if (m.matches()) {
		long value = Long.parseLong(m.group(1));
		Range range = Range.getRangeByPrefix(m.group(2));
		if (range != null) {
		    value *= range.getMultiplier();
		}
		// Restrict range to less than a terabyte
		if (value >= -MULT_TB && value < MULT_TB)
		    return value;
		throw new NumberFormatException(Intl.getString("util#numeric.outsideKMGRange"));
	    }
	    else
		throw new NumberFormatException(Intl.getString("util#numeric.badKMGFormat"));
	}


	/**
	 * Format a value using the {@link Range} enum to put into a readable range.
	 *
	 * @param	value	The input value to format.
	 * @return		The value formatted to an appropriate range.
	 */
	public static String formatToRange(long value) {
	    Range r = Range.getRangeOfValue(value);
	    if (r == Range.BYTES)
		return String.format("%1$d %2$s", value, r.getShortName());
	    else {
		double scaledValue = (double)value / (double)r.getMultiplier();
		String name = r.getShortName();
		if (scaledValue < 10.0d)
		    return String.format("%1$3.2f %2$s", scaledValue, name);
		else if (scaledValue < 100.0d)
		    return String.format("%1$3.1f %2$s", scaledValue, name);
		else
		    return String.format("%1$3.0f %2$s", scaledValue, name);
	    }
	}


	/**
	 * Format a value using the {@link Range} enum to put into a readable range,
	 * but use just the prefix (to save space).
	 *
	 * @param	value	The input value to format.
	 * @return		The value formatted (short form) to an appropriate range.
	 */
	public static String formatToRangeShort(long value) {
	    Range r = Range.getRangeOfValue(value);
	    if (r == Range.BYTES)
		return String.format("%1$d B", value);
	    else {
		double scaledValue = (double)value / (double)r.getMultiplier();
		String prefix = r.getPrefix();
		if (scaledValue < 10.0d)
		    return String.format("%1$3.2f %2$sB", scaledValue, prefix);
		else if (scaledValue < 100.0d)
		    return String.format("%1$3.1f %2$sB", scaledValue, prefix);
		else
		    return String.format("%1$3.0f %2$sB", scaledValue, prefix);
	    }
	}


	/**
	 * The "long" range name will be something like "Kilobytes", or "Megabytes".
	 *
	 * @param	value	The input value to test for range.
	 * @return		The long name of the appropriate range for this value.
	 */
	public static String getLongRangeName(long value) {
	    return Range.getRangeOfValue(value).getLongName();
	}


	/**
	 * Convert a long number to words.
	 * <p>Examples:
	 * <ul><li>10 -&gt; ten
	 * <li>27 -&gt; twenty-seven
	 * <li>493 -&gt; four hundred ninety-three
	 * </ul>
	 *
	 * @param	value	The value to convert.
	 * @return		The value written out as its English name.
	 */
	public static String convertToWords(long value) {
	    StringBuilder buf = new StringBuilder();
	    convertToWords(value, buf);
	    return buf.toString();
	}

	public static void convertToWords(long value, StringBuilder buf) {
	    if (value < 0L) {
		if (value == Long.MIN_VALUE) {
		    throw new IllegalArgumentException(Intl.getString("util#numeric.outOfRange"));
		}
		buf.append(minus).append(' ');
		value = -value;
	    }
	    if (value < 20L) {
		buf.append(smallWords[(int)value]);
	    }
	    else if (value < 100L) {
		int decade = (int)(value / 10L);
		int residual = (int)(value % 10L);
		buf.append(tensWords[decade - 2]);
		if (residual != 0) {
		    buf.append('-');
		    buf.append(smallWords[residual]);
		}
	    }
	    else {
		for (int i = 1; i < rangeValues.length; i++) {
		    if (value <= rangeValues[i]) {
			long scale = rangeValues[i - 1] + 1L;
			long prefix = value / scale;
			long residual = value % scale;
			convertToWords(prefix, buf);
			buf.append(' ').append(rangeWords[i - 1]);
			if (residual != 0L) {
			    buf.append(' ');
			    convertToWords(residual, buf);
			}
			break;
		    }
		}
	    }
	}


	/**
	 * Convert a BCD-format byte string into a {@link BigDecimal} value.
	 *
	 * @param bcdBytes	The BCD-encoded byte string.
	 * @return		The {@link BigDecimal} equivalent.
	 * @throws IllegalArgumentException if the input bytes are not valid BCD.
	 */
	public static BigDecimal convertBCDToDecimal(byte[] bcdBytes) {
	    String decimalString = convertBCDToString(bcdBytes);
	    return new BigDecimal(decimalString);
	}


	/**
	 * Convert a BCD-format byte string into a {@link BigInteger} value.
	 *
	 * @param bcdBytes	The BCD-encoded byte string.
	 * @return		The {@link BigInteger} equivalent.
	 * @throws IllegalArgumentException if the input bytes are not valid BCD.
	 */
	public static BigInteger convertBCDToInteger(byte[] bcdBytes) {
	    String integerString = convertBCDToString(bcdBytes);
	    return new BigInteger(integerString);
	}


	/**
	 * Convert a BCD-format byte string into a string value, which can then
	 * be converted to a {@link BigDecimal} or {@link BigInteger}.
	 *
	 * @param bcdBytes	The BCD-encoded byte string.
	 * @return		The string equivalent.
	 * @throws IllegalArgumentException if the input bytes are not valid BCD.
	 */
	public static String convertBCDToString(byte[] bcdBytes) {
	    StringBuilder buf = new StringBuilder(bcdBytes.length * 2 + 2);
	    int scale = bcdBytes[0];
	    int pos = 0;
	    char sign = '+';
	    // Put in the decimal and leading zeroes
	    if (scale < 0) {
		buf.append('.');
		for (int j = 0; j < -scale; j++) {
		    buf.append('0');
		}
	    }
	    for (int i = 1; i < bcdBytes.length; i++) {
		int highNibble = (bcdBytes[i] & 0xF0) >>> 4;
		int lowNibble  = (bcdBytes[i] & 0x0F);
		if (pos == scale) {
		    buf.append('.');
		}
		if (highNibble > 9) {
		    if (highNibble == 0x0D) {
			sign = '-';
		    }
		    break;
		}
		else {
		    buf.append((char)(highNibble + '0'));
		    pos++;
		}
		if (pos == scale) {
		    buf.append('.');
		}
		if (lowNibble > 9) {
		    if (lowNibble == 0x0D) {
			sign = '-';
		    }
		    break;
		}
		else {
		    buf.append((char)(lowNibble + '0'));
		    pos++;
		}
	    }
	    buf.insert(0, sign);

	    // Delete trailing decimal point so this works for BigInteger too
	    int last = buf.length() - 1;
	    if (buf.charAt(last) == '.')
		buf.deleteCharAt(last);

	    return buf.toString();
	}


	/**
	 * Convert from {@link BigDecimal} to BCD format (byte array).
	 *
	 * @param decimal	A {@link BigDecimal} value to convert.
	 * @return 		The BCD-encoded bytes of this value.
	 */
	public static byte[] convertToBCD(BigDecimal decimal) {
	    return convertToBCD(decimal.toPlainString());
	}


	/**
	 * Convert from {@link BigInteger} to BCD format (byte array).
	 *
	 * @param integer	A {@link BigInteger} value to convert.
	 * @return 		The BCD-encoded bytes of this value.
	 */
	public static byte[] convertToBCD(BigInteger integer) {
	    return convertToBCD(integer.toString());
	}


	/**
	 * Convert from numeric string to BCD format (byte array).
	 *
	 * @param plainText	A plain text numeric string to convert.
	 * @return 		The BCD-encoded bytes of this value.
	 */
	public static byte[] convertToBCD(String plainText) {
	    int plainLength = plainText.length();

	    // The format is going to be:
	    // optional sign
	    // some number (non-zero) of integer digits
	    // optional decimal point, and then
	    // optional fractional digits
	    int i = 0;
	    int sign = 0x0C;	// positive
	    if (plainText.charAt(i) == '-') {
		sign = 0x0D;
		i++;
	    }
	    else if (plainText.charAt(i) == '+') {
		i++;
	    }
	    // First pass, compute scale and count # digits
	    int scale = 0;
	    int digits = 0;
	    boolean pointSeen = false;
	    for (int j = i; j < plainLength; j++) {
		// Skip leading zeros
		if (!pointSeen && scale == 0 && plainText.charAt(j) == '0') {
		    i++;
		}
		// Note: the "BigDecimal.toPlainString()" method produces a
		// canonical form, not affected by Locale, so we are safe to
		// use '.' here.
		else if (plainText.charAt(j) == '.') {
		    pointSeen = true;
		}
		else if (plainText.charAt(j) == '0') {
		    if (pointSeen && digits == 0) {
			scale--;
		    }
		    else {
			digits++;
			if (!pointSeen)
			    scale++;
		    }
		}
		else {
		    digits++;
		    if (!pointSeen)
			scale++;
		}
	    }
	    int byteLength = (digits + 2) / 2 + 1 /* for scale */;
	    byte[] bytes = new byte[byteLength];
	    int pos = 0;
	    pointSeen = false;
	    bytes[0] = (byte)scale;
	    for (int j = i; j < plainLength; j++) {
		if (plainText.charAt(j) == '.') {
		    pointSeen = true;
		    continue;
		}
		else if (plainText.charAt(j) == '0') {
		    if (pointSeen && pos == 0) {
			continue;
		    }
		}
		int ch = plainText.charAt(j);
		int nibble = ch - '0';
		if ((pos & 1) == 0) {
		    // even nibble = high nibble of the byte
		    bytes[(pos / 2) + 1] = (byte)(nibble << 4);
		}
		else {
		    // odd nibble = low nibble (combine with existing high)
		    bytes[(pos / 2) + 1] |= nibble;
		}
		pos++;
	    }
	    // Add the sign in as the last nibble
	    if ((pos & 1) == 0) {
		bytes[(pos / 2) + 1] = (byte)(sign << 4);
	    }
	    else {
		bytes[(pos / 2) + 1] |= sign;
	    }

	    return bytes;
	}

	private static byte[] readBCDBytes(DataInputStream dis)
		throws IOException
	{
	    ByteArrayOutputStream baos = new ByteArrayOutputStream(256);
	    // First byte is scale, so don't do the sign nibble check on it
	    byte b = dis.readByte();
	    baos.write(b);
	    int hi, lo;
	    do {
		b = dis.readByte();
		baos.write(b);
		hi = ((int)b) & 0xC0;
		lo = ((int)b) & 0x0C;
	    } while (hi != 0xC0 && lo != 0x0C);
	    return baos.toByteArray();
	}

	private static char readChar(DataInputStream dis, ByteOrder byteOrder)
		throws IOException
	{
	    if (byteOrder == ByteOrder.LSB) {
		return (char)readShort(dis, byteOrder);
	    }
	    return dis.readChar();
	}

	private static void writeChar(DataOutputStream dos, char ch, ByteOrder byteOrder)
		throws IOException
	{
	    if (byteOrder == ByteOrder.LSB) {
		writeShort(dos, (short)ch, byteOrder);
	    }
	    else {
		dos.writeChar(ch);
	    }
	}

	private static short readShort(DataInputStream dis, ByteOrder byteOrder)
		throws IOException
	{
	    // This is "network" byte order, or MSB first
	    short value = dis.readShort();
	    if (byteOrder == ByteOrder.LSB) {
		return (short)Integer.rotateRight(Integer.reverseBytes((int)value), 16);
	    }
	    return value;
	}

	private static void writeShort(DataOutputStream dos, short value, ByteOrder byteOrder)
		throws IOException
	{
	    if (byteOrder == ByteOrder.LSB) {
		dos.writeShort((short)Integer.rotateRight(Integer.reverseBytes((int)value), 16));
	    }
	    else {
		dos.writeShort(value);
	    }
	}

	private static int readInt(DataInputStream dis, ByteOrder byteOrder)
		throws IOException
	{
	    int value = dis.readInt();
	    if (byteOrder == ByteOrder.LSB) {
		return Integer.reverseBytes(value);
	    }
	    return value;
	}

	private static void writeInt(DataOutputStream dos, int value, ByteOrder byteOrder)
		throws IOException
	{
	    if (byteOrder == ByteOrder.LSB) {
		dos.writeInt(Integer.reverseBytes(value));
	    }
	    else {
		dos.writeInt(value);
	    }
	}

	private static long readLong(DataInputStream dis, ByteOrder byteOrder)
		throws IOException
	{
	    long value = dis.readLong();
	    if (byteOrder == ByteOrder.LSB) {
		return Long.reverseBytes(value);
	    }
	    return value;
	}

	private static void writeLong(DataOutputStream dos, long value, ByteOrder byteOrder)
		throws IOException
	{
	    if (byteOrder == ByteOrder.LSB) {
		dos.writeLong(Long.reverseBytes(value));
	    }
	    else {
		dos.writeLong(value);
	    }
	}

	private static float readFloat(DataInputStream dis, ByteOrder byteOrder)
		throws IOException
	{
	    return Float.intBitsToFloat(readInt(dis, byteOrder));
	}

	private static void writeFloat(DataOutputStream dos, float value, ByteOrder byteOrder)
		throws IOException
	{
	    writeInt(dos, Float.floatToRawIntBits(value), byteOrder);
	}

	private static double readDouble(DataInputStream dis, ByteOrder byteOrder)
		throws IOException
	{
	    return Double.longBitsToDouble(readLong(dis, byteOrder));
	}

	private static void writeDouble(DataOutputStream dos, double value, ByteOrder byteOrder)
		throws IOException
	{
	    writeLong(dos, Double.doubleToRawLongBits(value), byteOrder);
	}

	private static String readString(DataInputStream dis, Charset charset, int byteLength)
		throws IOException
	{
	    byte[] bytes = new byte[byteLength];
	    dis.readFully(bytes);
	    return new String(bytes, charset);
	}

	private static void writeString(DataOutputStream dos, String value, Charset charset, ByteOrder byteOrder, StringLength stringLength, int length)
		throws IOException
	{
	    byte[] bytes = value.getBytes(charset);
	    int byteLen = bytes.length;
	    switch (stringLength) {
		case PREFIX1:
		    // Need a range of 0..255 here
		    if (byteLen > 255)
			throw new IndexOutOfBoundsException(Intl.formatString("util#numeric.stringLengthTooBig", byteLen, 255));
		    dos.write(byteLen);
		    dos.write(bytes);
		    break;
		case PREFIX2:
		    // Need a range of 0..65535 here
		    if (byteLen > 65535)
			throw new IndexOutOfBoundsException(Intl.formatString("util#numeric.stringLengthTooBig", byteLen, 65535));
		    writeShort(dos, (short)byteLen, byteOrder);
		    dos.write(bytes);
		    break;
		case PREFIX4:
		    writeInt(dos, byteLen, byteOrder);
		    dos.write(bytes);
		    break;
		case FIXED:
		    if (byteLen >= length) {
			// Note: silent truncation of the value!
			dos.write(bytes, 0, length);
		    }
		    else {
			dos.write(Arrays.copyOf(bytes, length));
		    }
		    break;
		case EOS:
		    dos.write(bytes);
		    dos.write('\0');
		    break;
	    }
	}


	public static Object readRawBinaryValue(DataInputStream dis, Charset charset,
		DataType dataType, ByteOrder byteOrder, StringLength stringLength, int length)
		throws IOException
	{
	     Object value = null;
	     int byteLen = length;
	     switch (dataType) {
		case NUL:
		    // Leave the value as null
		    break;
		case BYTE:
		    value = Byte.valueOf(dis.readByte());
		    break;
		case SHORT:
		    value = Short.valueOf(readShort(dis, byteOrder));
		    break;
		case INT:
		    value = Integer.valueOf(readInt(dis, byteOrder));
		    break;
		case LONG:
		    value = Long.valueOf(readLong(dis, byteOrder));
		    break;
		case BIGINT:
		    value = convertBCDToInteger(readBCDBytes(dis));
		    break;
		case DEC:
		    // Note: the last nibble of the value has the sign, so read until then.
		    value = convertBCDToDecimal(readBCDBytes(dis));
		    break;
		case FLOAT:
		    value = Float.valueOf(readFloat(dis, byteOrder));
		    break;
		case DOUBLE:
		    value = Double.valueOf(readDouble(dis, byteOrder));
		    break;
		case DATE:
		    long millis = readLong(dis, byteOrder);
		    value = new Date(millis);
		    break;
		case CHAR:
		    value = Character.valueOf(readChar(dis, byteOrder));
		    break;
		case STRING:
		    switch (stringLength) {
			case PREFIX1:
			    // Need a range of 0..255 here
			    byteLen = dis.readUnsignedByte();
			    value = readString(dis, charset, byteLen);
			    break;
			case PREFIX2:
			    // Need a range of 0..65535 here
			    byteLen = ((int)readShort(dis, byteOrder)) & 0xFFFF;
			    value = readString(dis, charset, byteLen);
			    break;
			case PREFIX4:
			    byteLen = readInt(dis, byteOrder);
			    // Fall through
			case FIXED:
			    value = readString(dis, charset, byteLen);
			    break;
			case EOS:
			    ByteArrayOutputStream baos = new ByteArrayOutputStream(256);
			    byte b = dis.readByte();
			    while (b != 0x00) {
				baos.write(b);
				b = dis.readByte();
			    }
			    value = new String(baos.toByteArray(), charset);
			    break;
		    }
		    break;
	     }
	     return value;
	}


	/**
	 * Read an arbitrary data type from the given {@link DataInputStream}
	 * as it was written by {@link #writeBinaryValue}.  Esp. the BCD data
	 * is an uncommon format.
	 * <p> Each piece of data is preceded by a one-byte data type code
	 * given by the {@link DataType} enum/code.  This does two things:
	 * <ul><li>Provides a fool-proof way to interpret the following bytes,</li>
	 * <li>And gives a way to encode a {@code null} value in the streami.</li>
	 * </ul>
	 *
	 * @param dis The data stream to read from.
	 * @param charset The character set to use to interpret string data.
	 * @return The object read or {@code null} if the value byte was
	 * {@link DataType#NUL}.
	 * @throws IOException especially for end of file
	 * @throws EOFException at the end of the file
	 */
	public static Object readBinaryValue(DataInputStream dis, Charset charset)
		throws IOException
	{
	     byte code = dis.readByte();
	     DataType dataType = DataType.fromCode((int)code);
	     return readRawBinaryValue(dis, charset, dataType, ByteOrder.MSB, StringLength.PREFIX4, -1);
	}

	/**
	 * Write an abitrary piece of data in raw binary form to the given stream.
	 *
	 * @param value Any wrapped primitive data type, or a {@link String}.
	 * @param dos The data stream to write to.
	 * @param charset The character set to use to convert strings to bytes.
	 * @param byteOrder Whether the bytes are in MSB..LSB or LSB..MSB order.
	 * @param stringLength The discipline to use for writing the string length.
	 * @param length For a fixed string length, the length to use, otherwise ignored.
	 *
	 * @throws IOException if there is a problem doing the write.
	 * @throws IllegalArgumentException if the data type isn't recognized.
	 */
	public static void writeRawBinaryValue(Object value, DataOutputStream dos, Charset charset,
		ByteOrder byteOrder, StringLength stringLength, int length)
			throws IOException
	{
	    // TODO: if the value is null, write nothing.... is this the right thing to do?
	    if (value == null)
		return;
	    Class<?> clazz = value.getClass();
	    if (clazz == Byte.class) {
		dos.writeByte(((Byte)value).intValue());
	    }
	    else if (clazz == Character.class) {
		writeChar(dos, ((Character)value).charValue(), byteOrder);
	    }
	    else if (clazz == Short.class) {
		writeShort(dos, ((Short)value).shortValue(), byteOrder);
	    }
	    else if (clazz == Integer.class) {
		writeInt(dos, ((Integer)value).intValue(), byteOrder);
	    }
	    else if (clazz == Long.class) {
		writeLong(dos, ((Long)value).longValue(), byteOrder);
	    }
	    else if (clazz == Float.class) {
		writeFloat(dos, ((Float)value).floatValue(), byteOrder);
	    }
	    else if (clazz == Double.class) {
		writeDouble(dos, ((Double)value).doubleValue(), byteOrder);
	    }
	    else if (clazz == BigDecimal.class) {
		dos.write(convertToBCD((BigDecimal)value));
	    }
	    else if (clazz == BigInteger.class) {
		dos.write(convertToBCD((BigInteger)value));
	    }
	    else if (clazz == String.class) {
		writeString(dos, (String)value, charset, byteOrder, stringLength, length);
	    }
	    else {
		throw new IllegalArgumentException(Intl.formatString("util#numeric.badDataType", clazz.getName()));
	    }
	}

	/**
	 * Write an arbitrary data type to the given {@link DataOutputStream}.
	 * <p> The convention for these files is to write a byte type for each
	 * field, defined by the {@link DataType} enum
	 *
	 * @param value Any wrapped primitive data type, or a {@link String}.
	 * @param dos The data stream to write to.
	 * @param charset The character set to use to convert strings to bytes.
	 * @throws IOException if there is a problem doing the write.
	 * @throws IllegalArgumentException if the data type isn't recognized.
	 */
	public static void writeBinaryValue(Object value, DataOutputStream dos, Charset charset)
		throws IOException
	{
	    if (value == null) {
		dos.writeByte(DataType.NUL.getCode());
	    }
	    else {
		Class<?> clazz = value.getClass();
		if (clazz == String.class) {
		    dos.writeByte(DataType.STRING.getCode());
		}
		else if (clazz == BigDecimal.class) {
		    dos.writeByte(DataType.DEC.getCode());
		}
		else if (clazz == BigInteger.class) {
		    dos.writeByte(DataType.BIGINT.getCode());
		}
		else if (clazz == Long.class) {
		    dos.writeByte(DataType.LONG.getCode());
		}
		else if (clazz == Integer.class) {
		    dos.writeByte(DataType.INT.getCode());
		}
		else if (clazz == Short.class) {
		    dos.writeByte(DataType.SHORT.getCode());
		}
		else if (clazz == Byte.class) {
		    dos.writeByte(DataType.BYTE.getCode());
		}
		else if (clazz == Double.class) {
		    dos.writeByte(DataType.DOUBLE.getCode());
		}
		else if (clazz == Float.class) {
		    dos.writeByte(DataType.FLOAT.getCode());
		}
		else if (clazz == Date.class) {
		    dos.writeByte(DataType.DATE.getCode());
		}
		else if (clazz == Character.class) {
		    dos.writeByte(DataType.CHAR.getCode());
		}
		else {
		    throw new IllegalArgumentException(Intl.formatString("util#numeric.badDataType", clazz.getName()));
		}
	    }
	    writeRawBinaryValue(value, dos, charset, ByteOrder.MSB, StringLength.PREFIX4, -1);
	}


	/**
	 * Round up a value to the next highest power of two.
	 *
	 * @param n Any non-negative number.
	 * @return The next highest power of two greater or equal to
	 * the input.
	 */
	public static int roundUpPowerTwo(int n) {
	    int p = 1;

	    // Check for exact power of two
//	    if (n != 0 && (n & (n - 1)) == 0)
//		return n;

	    while (p < n)
		p <<= 1;
	
	    return p;
	}


	/**
	 * @return The result of the base to the exp power, done in <code>BigDecimal</code>
	 * precision.
	 * @param base The number to raise to the given power.
	 * @param exp The power to raise the number to.
	 * @throws IllegalArgumentException if the exponent is infinite or not-a-number.
	 */
	public static BigDecimal pow(BigDecimal base, double exp) {
	    if (Double.isNaN(exp) || Double.isInfinite(exp))
		throw new IllegalArgumentException(Intl.getString("util#numeric.outOfRange"));
	    if (exp == 0.0d)
		return BigDecimal.ONE;
	    boolean reciprocal = false;
	    if (exp < 0) {
		reciprocal = true;
		exp = -exp;
	    }

	    int intExp = (int)Math.floor(exp);
	    double fracExp = exp - (double)intExp;

	    BigDecimal result = BigDecimal.ONE;
	    BigDecimal mult = base;
	    while (intExp != 0) {
		if (intExp % 2 == 1)
		    result = result.multiply(mult);
		intExp >>= 1;
		mult = mult.multiply(mult);
	    }

	    // 2.14**2.14 = 2.14**2 * 2.14**.14
	    BigDecimal fracResult = new BigDecimal(Math.pow(base.doubleValue(), fracExp));
	    result = result.multiply(fracResult);

	    if (reciprocal) {
		result = BigDecimal.ONE.divide(result);
	    }

	    return result;
	}


	/**
	 * @return The result of the base to the exp power, done in <code>BigInteger</code>,
	 * or <code>BigDecimal</code> precision depending on the value of the exponent.
	 * @param base The number to raise to the given power.
	 * @param exp The power to raise the number to.
	 * @throws IllegalArgumentException if the exponent is infinite, or not-a-number.
	 */
	public static Number pow(BigInteger base, double exp) {
	    if (Double.isNaN(exp) || Double.isInfinite(exp))
		throw new IllegalArgumentException(Intl.getString("util#numeric.outOfRange"));
	    if (exp == 0.0d)
		return BigInteger.ONE;

	    // Test for negative or fractional powers and convert to BigDecimal for those cases
	    double wholeExp = Math.floor(exp);
	    if (exp < 0.0d || wholeExp != exp) {
		return pow(new BigDecimal(base), exp);
	    }

	    int intExp = (int)wholeExp;
	    return base.pow(intExp);
	}


	/**
	 * @return A {@link BigDecimal} constant of PI to the requested number of fractional digits
	 * (up to 10,000).
	 */
	public static BigDecimal pi(final int digits) {
	    final int maxLength = PI_DIGITS.length() - 2;
	    if (digits > maxLength)
		throw new IllegalArgumentException(Intl.formatString("util#numeric.tooManyDigits", maxLength));

	    // Use +2 because the string has "3." at the beginning
	    return new BigDecimal(PI_DIGITS.substring(0, digits + 2));
	}

	/**
	 * @return A {@link BigDecimal} constant of E to the requested number of fractional digits
	 * (up to 10,000).
	 */
	public static BigDecimal e(final int digits) {
	    final int maxLength = E_DIGITS.length() - 2;
	    if (digits > maxLength)
		throw new IllegalArgumentException(Intl.formatString("util#numeric.tooManyDigits", maxLength));

	    // Use +2 because the string has "2." at the beginning
	    return new BigDecimal(E_DIGITS.substring(0, digits + 2));
	}

}
