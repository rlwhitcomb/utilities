//** Version: 2.8.10 Base: 1.9.3
//** The versions above must conform to the latest values in "version.properties" and "build.properties"

/*
 * A series of functions that provide some added value to Calculator.
 */

/*
 * The system-defined line ending.
 */
const EOL = info.os.linesep

/*
 * Whether we are running on Windows vs. something else.
 */
const ON_WINDOWS = info.os.id == 'windows'

/*
 * Convert one of our dates to an Excel date serial number
 * where 1/1/1900 is considered day 1 (BUT 1900 is also considered [erroneously] as a leap year).
 * From here: https://docs.microsoft.com/en-us/office/troubleshoot/excel/determine-a-leap-year
 * "However, in order to be compatible with other programs, Microsoft Excel treats the year 1900 as a leap year."
 *
 * @param date The input date value
 * @return     The Excel date serial number, where 1/1/1900 is 1
 */
def excel_date(date) = { date < D'3/1/1900' ? date - D'1/1/1900' + 1 : date - D'1/1/1900' + 2 }

/*
 * Convert one of our dates to an Excel date serial number using the 1904 system
 * where 1/1/1904 is considered day 0.
 *
 * @param date The input date value
 * @return     The Excel 1904-system date serial number, where 1/1/1904 is 0
 */
def excel_date_1904(date) = { date - D'1/1/1904' }

/*
 * Helpers for the Excel column conversion code.
 */
define to_int(c) = { eval(`${c@d}`) }
const _A_ = to_int('A')
const _Z_ = to_int('Z')
const _BASE_ = _Z_ - _A_ + 1
define to_alpha(v) = { `${(_A_ + v)@c}` }

/*
 * Convert a numeric Excel column index (1..16384) into a regular column name ("A" .. "XFD").
 *
 * @param index The numeric column index to convert.
 * @return      The column name.
 *
 * Algorithm taken from example given here:
 * https://stackoverflow.com/questions/181596/how-to-convert-a-column-number-e-g-127-into-an-excel-column-e-g-aa
 */
define to_excel_col(idx) = {
   _col = ''
   _i = idx - 1
   while _i >= 0 {
      _col = to_alpha(_i % _BASE_) + _col
      _i = _i \ _BASE_ - 1
   }
   _col
}

/*
 * Convert an Excel column name ("A" .. "XFD") to a numeric column index (1..16384).
 *
 * @param col The column name to convert.
 * @return    The numeric index of the column.
 */
define from_excel_col(col) = {
   _col = 0
   loop c over chars(upper(col)) {
      _v = c - _A_ + 1
      _col *= _BASE_
      _col += _v
   }
}

/*
 * Convert radians to degrees: 2*pi = 360, so radians / pi * 180 = degrees
 *
 * @param rad The input radians value
 * @return    Computed degrees
 */
def rad_to_deg(rad) = { rad / pi * 180 }

/*
 * Convert degrees to radians: 2*pi = 360, so degrees / 180 * pi = radians
 *
 * @param deg The input degrees value
 * @return    Computed radians
 */
def deg_to_rad(deg) = { deg / 180 * pi }

/*
 * Get the day of week name for a given date.
 *
 * @param date The input date value.
 * @return     The day name ("Sunday" .. "Saturday").
 */
def dow_name(date) = { info.locale.weekdays [ dow(date) ] }

/*
 * Get the month name for a given date.
 *
 * @param date The input date value.
 * @return     The month name ("January" .. "December").
 */
def moy_name(date) = { info.locale.months [ moy(date) - 1 ] }

/*
 * Get the long form of a date.
 * From D'2/1/1980' -> Friday, February 1, 1980
 *
 * @param date The input date value, defaults to "today" if omitted.
 * @return     The long string representation of the date.
 */
def long_date(date = today) = { `${dow_name(date)}, ${moy_name(date)} ${dom(date)}, ${yod(date)@_d}` }

/*
 * Convert a surrogate pair to the corresponding Unicode codepoint.
 *
 * @param h The high surrogate value.
 * @param l The low surrogate.
 */
define surr_pair_to_cp(h, l) = { (h - 0xD800) * 0x400 + (l - 0xDC00) + 0x10000 }

/*
 * Extract the high surrogate of a codepoint outside the BMP.
 *
 * @param cp The codepoint under dissection.
 * @return   The high surrogate value for this codepoint.
 */
define cp_to_high_surr(cp) = { (cp - 0x10000) \ 0x400 + 0xD800 }

/*
 * Extract the low surrogate of a codepoint outside the BMP.
 *
 * @param cp The codepoint under dissection.
 * @return   The low surrogate value for this codepoint.
 */
define cp_to_low_surr(cp) = { (cp - 0x10000) % 0x400 + 0xDC00 }

/*
 * For time values, number of ticks (nanoseconds) in a second.
 */
TICKS_PER_SECOND = 1e9
/*
 * For time values, the number of ticks in a minute.
 */
TICKS_PER_MINUTE = TICKS_PER_SECOND * 60
/*
 * For time values, the number of ticks in an hour.
 */
TICKS_PER_HOUR = TICKS_PER_MINUTE * 60

/*
 * Get the number of hours in a time value.
 *
 * @param time The time value (as from "now")
 * @return     The integer number of hours.
 */
define hot(time) = { time \ TICKS_PER_HOUR }

/*
 * Get the number of minutes in a time value.
 *
 * @param time The time value (as from "now")
 * @return     The integer number of minutes.
 */
define mot(time) = { (time - (hot(time) * TICKS_PER_HOUR)) \ TICKS_PER_MINUTE }

/*
 * Get the number of seconds in a time value.
 *
 * @param time The time value (as from "now")
 * @return     The integer number of seconds.
 */
define sot(time) = { (time - (hot(time) * TICKS_PER_HOUR) - (mot(time) * TICKS_PER_MINUTE)) \ TICKS_PER_SECOND }

/*
 * Get a timestamp from the given date and time in the Linux "date" form.
 *
 * @param date The desired date.
 * @param time The desired time.
 * @return     Timestamp in the form of "Mon Dec 20  6:46:19 PST 2021"
 */
def timestamp(date = today, time = now) = {
   `${substr(dow_name(date),0,3)} ${substr(moy_name(date),0,3)} ${dom(date)@.2d} ${hot(time)@-2s}:${mot(time)@.2d}:${sot(time)@.2d} ${info.timezone.name} ${yod(date)@_d}`
}

/*
 * Compute the flat map of an array.
 *
 * @param arr The input array.
 * @return    The flat map of that array.
 */
def flat_map(arr) = { eval `[${join arr, ','}]` }

/*
 * Determine if a given number is a "perfect" number - equal to the sum of
 * all its positive divisors, excluding itself.
 * Note: the first few perfect numbers are: 6, 28, 496, and 8128.
 *
 * @param n The test value.
 * @return  true/false if the number is perfect.
 */
define is_perfect(n) = { sumof ( factors (n) ) - n == n }

/*
 * Solve the quadratic formula to find the roots of a general
 * quadratic equation: a*x**2 + b*x + c = 0.
 * x = (-b +- sqrt(b**2 - 4 * a * c))/2*a
 *
 * @param a
 * @param b
 * @param c
 * @return [ x1, x2 ] if solution is real, error if not
 */
define quad(a, b, c) = {
  _b2 = b * b
  _2a = 2 * a
  _r = (_b2 - 4 * a * c)
  if _r < 0 {
    _r = abs(_r)
    [ ( -b/_2a, sqrt(_r)/_2a ), ( -b/_2a, -sqrt(_r)/_2a ) ]
  } else {
    [ (-b + sqrt(_r))/_2a, (-b - sqrt(_r))/_2a ]
  }
}

/*
 * Find the value of a quadratic equation at the given point.
 * y = a*x**2 + b*x + c
 *
 * @param a
 * @param b
 * @param c
 * @param x
 * @return The value of the equation at the given point.
 */
define quad_exp(a, b, c, x) = {
  a * x*x + b * x + c
}

/*
 * The Euler-Riemann "zeta" function for positive integer even values.
 * Reference:
 * https://en.wikipedia.org/wiki/Riemann_zeta_function
 *
 * @param _2n Positive even integer value
 * @return    The Euler "zeta" function of that value
 * Note: no error checking if the parameter is not a positive even integer.
 */
define zeta_2n(_2n) = { ((-1)**(_2n / 2 + 1) * Bn(_2n) * (2 * pi) ** _2n) / (2 * _2n!) }

/*
 * Tangent numbers, derived from the Bernoulli numbers. Value is zero for 0
 * and all even values.
 * Reference: http://scipp.ucsc.edu/~haber/ph116A/taylor11.pdf pg. 3 eq. 8
 *
 * @param k where we calculate the value for (2k+1)
 * @return The k-th Tangent number
 */
define Tn(k) = {
  _2k2 = 2*k + 2
  _2_2k2 = 2 ** _2k2
  :rational on
  _fact = Bn(_2k2) / _2k2
  _result = _2_2k2 * (_2_2k2 - 1) * _fact
  :rational pop
  _result@d
}

#
# M = P[r(1+r)^n/((1+r)^n)-1)]
#
#  M = the total monthly mortgage payment
#  P = the principal loan amount
#  r = your monthly interest rate. Lenders provide you an annual rate
#      so you'll need to divide that figure by 12 (the number of month
#      in a year) to get the monthly rate. If your interest rate is 5%,
#      your monthly rate would be 0.004167 (0.05/12=0.004167).
#  n = number of payments over the loan's lifetime. Multiply the number
#      of years in your loan term by 12 (the number of months in a year)
#      to get the number of total payments for your loan. For example,
#      a 30-year fixed mortgage would have 360 payments (30x12=360).
#

# Note: this particular example comes from
# https://www.bankrate.com/calculators/mortgages/mortgage-calculator.aspx

# The context for the payment calculation is:
#    P = full principal amount to be financed
#    R = yearly interest rate (%)
# or r = monthly interest rate (%/12)
#    N = number of years
# or n = number of months (N*12)
# Then the calculated values are:
#   rate = monthly interest as a decimal value (% / 100 / 12)
#   num = number of months (years * 12)
define _pmt_internal_(ctx) = {
  ctx.rate = (ctx.R ? (ctx.R / 12) : ctx.r) / 100
  ctx.num = (ctx.N ? (ctx.N * 12) : ctx.n)

  # Calculate the intermediate values (which are reused)
  r_n = (1 + ctx.rate) ** ctx.num
  r_r_n = ctx.rate * r_n
  r_n_1 = r_n - 1

  # Now the final monthly payment value
  ctx.P * (r_r_n / r_n_1)
}

define PMT(P,R,N) = {
   # Note: the 2nd param is the number of fractional digits (after the decimal point)
   # regardless of the number of whole digits in the result; so "0" will round
   # to a whole dollar, "2" rounds to pennies.
   round(_pmt_internal_({P:P, R:R, N:N}), 2)
}

define PMT2(P,r,n) = {
   round(_pmt_internal_({P:P, r:r, n:n}), 2)
}

def monthly(P,R,N) = { `Full monthly payment is ${PMT(P,R,N)@2,$}` }
def monthly_whole(P,R,N) = { `Monthly payment in whole dollars is ${PMT(P,R,N)@0,$}` }

def help_mort = { "\nUsage: PMT(P=<present value>,R=<yearly interest rate (%)>,N=<number of years>)\n    or PMT2(P,r=<monthly interest %>,n=<number of months>)\n   Or use monthly(P,R,N) or monthly_whole(P,R,N) to get the results in different forms." }

/*
 * Compute the winning percentage, given wins, ties, and losses.
 *
 * @param wins   Number of wins.
 * @param losses Number of times lost.
 * @param ties   Number of ties (default 0).
 * @return       Winning percentage.
 */
def win_pct(wins, losses, ties = 0) = { wins / (wins + ties + losses) @2% }

/*
 * Implementation of a stack data structure. The array of values is kept trimmed, so the current value array length
 * is also the current depth.
 */
def stack = { _values: [] }

/*
 * Push a new value onto the given stack.
 *
 * @param s     The stack to use.
 * @param value The new value to push onto the top of the stack.
 */
def push(s, value) = { s._values[length(s._values)] = value }

/*
 * Pop the latest value off the given stack.
 *
 * @param s The stack to use.
 * @return  The latest value pushed into the stack.
 */
def pop(s) = { _v = splice(s._values, -1, 1); _v[0] }

/*
 * Is the given stack empty?
 *
 * @param s The stack to check on.
 * @return  Whether or not the stack is empty.
 */
def isempty(s) = { length(s._values) == 0 }

/*
 * Peek at the top value on the stack without popping it.
 *
 * @param s The stack to use.
 * @return   The top-most element of the stack, without modifying the stack.
 */
def peek(s) = { _len = length(s._values) - 1; _len < 0 ? null : s._values[_len] }

/*
 * Construct a nice string form of the version information.
 */
def versionstring = `Version ${info.version.major}.${info.version.minor}.${info.version.patch} build ${substr(info.version.build, 1)}${info.version.prerelease}`

/*
 * Execute the "uuid" program to return a unique identifier.
 *
 * @return A unique identifier.
 */
define uuid() = {  trim(exec('uuid')) }

/*
 * Execute the "sleep" program for the given time period.
 *
 * @param time A time period to sleep (could be "n" seconds, or other units such as "2m").
 */
define sleep(time) = { trim(exec('sleep', time)) }

/*
 * Hash a file using the given algorithm (default is "SHA-256" if none given).
 *
 * @param filename  Name of the file to compute the hash for.
 * @param algorithm Which hash algorithm to use.
 * @param uppercase Which case to use for the result (default 'false')
 * @return          The given hash value (lower case).
 */
define hash(filename, algorithm = 'sha-256', uppercase = false) = {
   trim(exec('hsh', uppercase ? '--upper' : '--lower', '--algorithm=' + algorithm, '--file', filename))
}

/*
 * Hash a string with same parameters as "hash".
 *
 * @param value     The string value to hash.
 * @param algorithm Which hash algorithm to use.
 * @param uppercase Which case to use for the results (default 'false')
 * @return          The given string's hash value.
 */
define hashstring(value, algorithm = 'sha-256', uppercase = false) = {
   trim(exec('hsh', '--line', uppercase ? '--upper' : '--lower', '--algorithm=' + algorithm, `${value@q}`))
}

/*
 * Compute the mean and standard deviation of a list of values.
 *
 * @param values
 * @return { mean: xxx, stddev: sss }
 */
define mean_stddev (values) = {
  len = length(values)
  avg = sumof(values) / len
  var = 0
  loop over values { var += (__ - avg) ** 2 }
  var /= len
  { mean: avg, stddev: round(sqrt(var), 3) }
}

