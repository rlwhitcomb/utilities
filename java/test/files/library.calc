:Require '2.13.20-alpha'
:Requires '2.13.20-alpha', Base '1.9.15-alpha'
// The versions above must conform to the latest values in "version.properties" and "build.properties"

/*
 * A series of functions that provide some added value to Calculator.
 */

/*
 * The system-defined line ending.
 */
const EOL = info.os.linesep

/*
 * Whether we are running on Windows vs. something else.
 */
const ON_WINDOWS = info.os.id == 'windows'

/*
 * Flag values for "sort"
 */
const SORT_CASE_INSENSITIVE = 0x0001
const SORT_SORT_KEYS        = 0x0002

/*
 * Flag values for "matches"
 */
const MATCH_CASE_INSENSITIVE = 0x0001
const MATCH_DOTALL           = 0x0002
const MATCH_UNICODE_CASE     = 0x0004
const MATCH_LITERAL          = 0x0008
const MATCH_MULTILINE        = 0x0010
const MATCH_UNIX_LINES       = 0x0020

/*
 * Color codes
 */
const ESC = '\o033'
const NORM = `$ESC[0`
const BOLD = `$ESC[1`
const UNDL = `$ESC[4`

const RESET   = `$ESC[0m`

const BLACK   = `$NORM;30m`
const RED     = `$NORM;31m`
const GREEN   = `$NORM;32m`
const YELLOW  = `$NORM;33m`
const BLUE    = `$NORM;34m`
const MAGENTA = `$NORM;35m`
const CYAN    = `$NORM;36m`
const WHITE   = `$NORM;37m`

const BLACK_BOLD   = `$BOLD;30m`
const RED_BOLD     = `$BOLD;31m`
const GREEN_BOLD   = `$BOLD;32m`
const YELLOW_BOLD  = `$BOLD;33m`
const BLUE_BOLD    = `$BOLD;34m`
const MAGENTA_BOLD = `$BOLD;35m`
const CYAN_BOLD    = `$BOLD;36m`
const WHITE_BOLD   = `$BOLD;37m`

const BLACK_UNDER   = `$UNDL;30m`
const RED_UNDER     = `$UNDL;31m`
const GREEN_UNDER   = `$UNDL;32m`
const YELLOW_UNDER  = `$UNDL;33m`
const BLUE_UNDER    = `$UNDL;34m`
const MAGENTA_UNDER = `$UNDL;35m`
const CYAN_UNDER    = `$UNDL;36m`
const WHITE_UNDER   = `$UNDL;37m`

const BLACK_BKGND   = `$ESC[40m`
const RED_BKGND     = `$ESC[41m`
const GREEN_BKGND   = `$ESC[42m`
const YELLOW_BKGND  = `$ESC[43m`
const BLUE_BKGND    = `$ESC[44m`
const MAGENTA_BKGND = `$ESC[45m`
const CYAN_BKGND    = `$ESC[46m`
const WHITE_BKGND   = `$ESC[47m`

const BLACK_BRIGHT   = `$NORM;90m`
const RED_BRIGHT     = `$NORM;91m`
const GREEN_BRIGHT   = `$NORM;92m`
const YELLOW_BRIGHT  = `$NORM;93m`
const BLUE_BRIGHT    = `$NORM;94m`
const MAGENTA_BRIGHT = `$NORM;95m`
const CYAN_BRIGHT    = `$NORM;96m`
const WHITE_BRIGHT   = `$NORM;97m`

const BLACK_BOLD_BRIGHT   = `$BOLD;90m`
const RED_BOLD_BRIGHT     = `$BOLD;91m`
const GREEN_BOLD_BRIGHT   = `$BOLD;92m`
const YELLOW_BOLD_BRIGHT  = `$BOLD;93m`
const BLUE_BOLD_BRIGHT    = `$BOLD;94m`
const MAGENTA_BOLD_BRIGHT = `$BOLD;95m`
const CYAN_BOLD_BRIGHT    = `$BOLD;96m`
const WHITE_BOLD_BRIGHT   = `$BOLD;97m`

const BLACK_UNDER_BRIGHT   = `$UNDL;90m`
const RED_UNDER_BRIGHT     = `$UNDL;91m`
const GREEN_UNDER_BRIGHT   = `$UNDL;92m`
const YELLOW_UNDER_BRIGHT  = `$UNDL;93m`
const BLUE_UNDER_BRIGHT    = `$UNDL;94m`
const MAGENTA_UNDER_BRIGHT = `$UNDL;95m`
const CYAN_UNDER_BRIGHT    = `$UNDL;96m`
const WHITE_UNDER_BRIGHT   = `$UNDL;97m`

const BLACK_BKGND_BRIGHT   = `$NORM;100m`
const RED_BKGND_BRIGHT     = `$NORM;101m`
const GREEN_BKGND_BRIGHT   = `$NORM;102m`
const YELLOW_BKGND_BRIGHT  = `$NORM;103m`
const BLUE_BKGND_BRIGHT    = `$NORM;104m`
const MAGENTA_BKGND_BRIGHT = `$NORM;105m`
const CYAN_BKGND_BRIGHT    = `$NORM;106m`
const WHITE_BKGND_BRIGHT   = `$NORM;107m`

/*
 * Convert one of our dates to an Excel date serial number
 * where 1/1/1900 is considered day 1 (BUT 1900 is also considered [erroneously] as a leap year).
 * From here: https://docs.microsoft.com/en-us/office/troubleshoot/excel/determine-a-leap-year
 * "However, in order to be compatible with other programs, Microsoft Excel treats the year 1900 as a leap year."
 *
 * @param date The input date value
 * @return     The Excel date serial number, where 1/1/1900 is 1
 */
def excel_date(date) = { date < D'3/1/1900' ? date - D'1/1/1900' + 1 : date - D'1/1/1900' + 2 }

/*
 * Convert one of our dates to an Excel date serial number using the 1904 system
 * where 1/1/1904 is considered day 0.
 *
 * @param date The input date value
 * @return     The Excel 1904-system date serial number, where 1/1/1904 is 0
 */
def excel_date_1904(date) = { date - D'1/1/1904' }

/*
 * Helpers for the Excel column conversion code.
 */
define to_int(c) = { eval(`${c@d}`) }
const _A_ = to_int('A')
const _Z_ = to_int('Z')
const _BASE_ = _Z_ - _A_ + 1
define to_alpha(v) = { `${(_A_ + v)@c}` }

/*
 * Convert a numeric Excel column index (1..16384) into a regular column name ("A" .. "XFD").
 *
 * @param index The numeric column index to convert.
 * @return      The column name.
 *
 * Algorithm taken from example given here:
 * https://stackoverflow.com/questions/181596/how-to-convert-a-column-number-e-g-127-into-an-excel-column-e-g-aa
 */
define to_excel_col(idx) = {
   _col = ''
   _i = idx - 1
   while _i >= 0 {
      _col = to_alpha(_i % _BASE_) + _col
      _i = _i \ _BASE_ - 1
   }
   _col
}

/*
 * Convert an Excel column name ("A" .. "XFD") to a numeric column index (1..16384).
 *
 * @param col The column name to convert.
 * @return    The numeric index of the column.
 */
define from_excel_col(col) = {
   _col = 0
   loop c over codes(upper(col)) {
      _v = c - _A_ + 1
      _col *= _BASE_
      _col += _v
   }
}

/*
 * Convert radians to degrees: 2*pi = 360, so radians / pi * 180 = degrees
 *
 * @param rad The input radians value
 * @return    Computed degrees
 */
def rad_to_deg(rad) = { rad / pi * 180 }

/*
 * Convert degrees to radians: 2*pi = 360, so degrees / 180 * pi = radians
 *
 * @param deg The input degrees value
 * @return    Computed radians
 */
def deg_to_rad(deg) = { deg / 180 * pi }

/*
 * Convert degrees Fahrenheit to degrees Celsius.
 *
 * @param f Degrees in Fahrenheit (32 = freezing point of water)
 * @return  Equivalent in degrees Celsius.
 */
def FtoC(f) = { (f - 32) * 5 / 9 }

/*
 * Convert degrees Celsius to degrees Fahrenheit.
 *
 * @param c Degrees in Celsius (0 = freezing point of water)
 * @return  Equivalent in degrees Fahrenheit.
 */
def CtoF(c) = { (c * 9 / 5) + 32 }

/*
 * Get the day of week name for a given date.
 *
 * @param date The input date value.
 * @return     The day name ("Sunday" .. "Saturday").
 */
def dow_name(date) = { info.locale.weekdays [ dow(date) ] }

/*
 * Get the month name for a given date.
 *
 * @param date The input date value.
 * @return     The month name ("January" .. "December").
 */
def moy_name(date) = { info.locale.months [ moy(date) - 1 ] }

/*
 * Get the long form of a date.
 * From D'2/1/1980' -> Friday, February 1, 1980
 *
 * @param date The input date value, defaults to "today" if omitted.
 * @return     The long string representation of the date.
 */
def long_date(date = today) = { `${dow_name(date)}, ${moy_name(date)} ${dom(date)}, ${yod(date)@_d}` }

/*
 * Convert a surrogate pair to the corresponding Unicode codepoint.
 *
 * @param h The high surrogate value.
 * @param l The low surrogate.
 */
define surr_pair_to_cp(h, l) = { (h - 0xD800) * 0x400 + (l - 0xDC00) + 0x10000 }

/*
 * Extract the high surrogate of a codepoint outside the BMP.
 *
 * @param cp The codepoint under dissection.
 * @return   The high surrogate value for this codepoint.
 */
define cp_to_high_surr(cp) = { (cp - 0x10000) \ 0x400 + 0xD800 }

/*
 * Extract the low surrogate of a codepoint outside the BMP.
 *
 * @param cp The codepoint under dissection.
 * @return   The low surrogate value for this codepoint.
 */
define cp_to_low_surr(cp) = { (cp - 0x10000) % 0x400 + 0xDC00 }

/*
 * For time values, number of ticks (nanoseconds) in a second.
 */
TICKS_PER_SECOND = 1e9
/*
 * For time values, the number of ticks in a minute.
 */
TICKS_PER_MINUTE = TICKS_PER_SECOND * 60
/*
 * For time values, the number of ticks in an hour.
 */
TICKS_PER_HOUR = TICKS_PER_MINUTE * 60

/*
 * Get the number of hours in a time value.
 *
 * @param time The time value (as from "now")
 * @return     The integer number of hours.
 */
define hot(time) = { time \ TICKS_PER_HOUR }

/*
 * Get the number of minutes in a time value.
 *
 * @param time The time value (as from "now")
 * @return     The integer number of minutes.
 */
define mot(time) = { (time - (hot(time) * TICKS_PER_HOUR)) \ TICKS_PER_MINUTE }

/*
 * Get the number of seconds in a time value.
 *
 * @param time The time value (as from "now")
 * @return     The integer number of seconds.
 */
define sot(time) = { (time - (hot(time) * TICKS_PER_HOUR) - (mot(time) * TICKS_PER_MINUTE)) \ TICKS_PER_SECOND }

/*
 * Get a timestamp from the given date and time in the Linux "date" form.
 *
 * @param date The desired date.
 * @param time The desired time.
 * @return     Timestamp in the form of "Mon Dec 20  6:46:19 PST 2021"
 */
def timestamp(date = today, time = now) = {
   `${substr(dow_name(date),0,3)} ${substr(moy_name(date),0,3)} ${dom(date)@.2d} ${hot(time)@-2s}:${mot(time)@.2d}:${sot(time)@.2d} ${info.timezone.name} ${yod(date)@_d}`
}

/*
 * Format a date according to the given format.
 *
 * @param d  The date value.
 * @param f  Format for the date, such as "mm/dd/yyyy" (default pattern).
 * @return   The date formatted according to the pattern.
 */
define dateformat(d, f = 'mm/dd/yyyy') = {
    define d2(n) = { n < 10 ? '0' + n : '' + n }
    define dg(n) = { '' + n }
    define finishRun(ch) = {
        len = length(runOf)
        if len {
            if ch == runOf[0] leave
            case runOf[0] of {
                'd': result +=
                        (len == 1 ? dg(dom(d)) : d2(dom(d))),
                'y': result +=
                        (len <= 2 ? d2(yod(d) % 100) : dg(yod(d))),
                'm': result +=
                        (len == 1 ? dg(moy(d)) : d2(moy(d))),
                'M': result +=
                        (len <= 2 ? substr(moy_name(d), 0, 3) : moy_name(d))
            }
        }
        runOf = ''
    }

    result = ''
    runOf = ''
    loop fch over f {
        case fch of {
            'd', 'm', 'M', 'y': {
                finishRun(fch)
                runOf += fch
            },
            default: {
                finishRun(fch)
                result += fch
            }
        }
    }
    finishRun('')
    result
}

/*
 * Complement to built-in "now" function, this returns the current time,
 * but in the GMT timezone.
 *
 * @return Current time at GMT (use "@h" to format as a time).
 */
def gmtnow = { now - eval(info.timezone.offset) }

/*
 * Compute the flat map of an array.
 *
 * @param arr The input array.
 * @return    The flat map of that array.
 */
def flat_map(arr) = { eval `[${join arr, ','}]` }

/*
 * Determine if a given number is a "perfect" number - equal to the sum of
 * all its positive divisors, excluding itself.
 * Note: the first few perfect numbers are: 6, 28, 496, and 8128.
 *
 * @param n The test value.
 * @return  true/false if the number is perfect.
 */
define is_perfect(n) = { sumof ( factors (n) ) - n == n }

/*
 * Solve the quadratic formula to find the roots of a general
 * quadratic equation: a*x**2 + b*x + c = 0.
 * x = (-b +- sqrt(b**2 - 4 * a * c))/2*a
 *
 * @param a
 * @param b
 * @param c
 * @return [ x1, x2 ] if solution is real, error if not
 */
define quad(a, b, c) = {
  _b2 = b * b
  _2a = 2 * a
  _r = (_b2 - 4 * a * c)
  if _r < 0 {
    _r = abs(_r)
    [ ( -b/_2a, sqrt(_r)/_2a ), ( -b/_2a, -sqrt(_r)/_2a ) ]
  } else {
    [ (-b + sqrt(_r))/_2a, (-b - sqrt(_r))/_2a ]
  }
}

/*
 * Find the value of a quadratic equation at the given point.
 * y = a*x**2 + b*x + c
 *
 * @param a
 * @param b
 * @param c
 * @param x
 * @return The value of the equation at the given point.
 */
define quad_exp(a, b, c, x) = {
  a * x**2 + b * x + c
}

/*
 * The Euler-Riemann "zeta" function for positive integer even values.
 * Reference:
 * https://en.wikipedia.org/wiki/Riemann_zeta_function
 *
 * @param _2n Positive even integer value
 * @return    The Euler "zeta" function of that value
 * Note: no error checking if the parameter is not a positive even integer.
 */
define zeta_2n(_2n) = { ((-1)**(_2n / 2 + 1) * Bn(_2n) * (2 * pi) ** _2n) / (2 * _2n!) }

/*
 * Tangent numbers, derived from the Bernoulli numbers. Value is zero for 0
 * and all even values.
 * Reference: http://scipp.ucsc.edu/~haber/ph116A/taylor11.pdf pg. 3 eq. 8
 *
 * @param k where we calculate the value for (2k+1)
 * @return The k-th Tangent number
 */
define Tn(k) = {
  _2k2 = 2*k + 2
  _2_2k2 = 2 ** _2k2
  :rational on {
    _fact = Bn(_2k2) / _2k2
    _result = _2_2k2 * (_2_2k2 - 1) * _fact
  }
  _result@d
}

#
# M = P[r(1+r)^n/((1+r)^n)-1)]
#
#  M = the total monthly mortgage payment
#  P = the principal loan amount
#  r = your monthly interest rate. Lenders provide you an annual rate
#      so you'll need to divide that figure by 12 (the number of month
#      in a year) to get the monthly rate. If your interest rate is 5%,
#      your monthly rate would be 0.004167 (0.05/12=0.004167).
#  n = number of payments over the loan's lifetime. Multiply the number
#      of years in your loan term by 12 (the number of months in a year)
#      to get the number of total payments for your loan. For example,
#      a 30-year fixed mortgage would have 360 payments (30x12=360).
#

# Note: this particular example comes from
# https://www.bankrate.com/calculators/mortgages/mortgage-calculator.aspx

# The context for the payment calculation is:
#    P = full principal amount to be financed
#    R = yearly interest rate (%)
# or r = monthly interest rate (%/12)
#    N = number of years
# or n = number of months (N*12)
# Then the calculated values are:
#   rate = monthly interest as a decimal value (% / 100 / 12)
#   num = number of months (years * 12)
define _pmt_internal_(ctx) = {
  ctx.rate = (ctx.R ? (ctx.R / 12) : ctx.r) / 100
  ctx.num = (ctx.N ? (ctx.N * 12) : ctx.n)

  # Calculate the intermediate values (which are reused)
  r_n = (1 + ctx.rate) ** ctx.num
  r_r_n = ctx.rate * r_n
  r_n_1 = r_n - 1

  # Now the final monthly payment value
  ctx.P * (r_r_n / r_n_1)
}

define PMT(P,R,N) = {
   # Note: the 2nd param is the number of fractional digits (after the decimal point)
   # regardless of the number of whole digits in the result; so "0" will round
   # to a whole dollar, "2" rounds to pennies.
   round(_pmt_internal_({P:P, R:R, N:N}), 2)
}

define PMT2(P,r,n) = {
   round(_pmt_internal_({P:P, r:r, n:n}), 2)
}

def monthly(P,R,N) = { `Full monthly payment is ${PMT(P,R,N)@2,$}` }
def monthly_whole(P,R,N) = { `Monthly payment in whole dollars is ${PMT(P,R,N)@0,$}` }

def help_mort = {
"""
Usage: PMT (P = present value, R = yearly interest rate (%), N = number of years)
   or PMT2 (P = present value, r = monthly interest (%), n = number of months)
   Or use monthly(P,R,N) or monthly_whole(P,R,N) to get the results in different forms.
"""
}

/*
 * Compute the winning percentage, given wins, ties, and losses.
 *
 * @param wins   Number of wins.
 * @param losses Number of times lost.
 * @param ties   Number of ties (default 0).
 * @return       Winning percentage.
 */
def win_pct(wins, losses, ties = 0) = { wins / (wins + ties + losses) @2% }

/*
 * Calculate percent increase from old to new value.
 *
 * @param old   Previous value.
 * @param new   New value.
 * @return      (new - previous) / previous as a percentage
 */
def pct_inc(old, new) = { `${( new - old ) / old * 100 @2d}%` }

/*
 * Implementation of a stack data structure. The array of values is kept trimmed, so the current value array length
 * is also the current depth.
 */
def stack = { _values: [] }

/*
 * Push a new value onto the given stack.
 *
 * @param s     The stack to use.
 * @param value The new value to push onto the top of the stack.
 */
def push(s, value) = { s._values += value }

/*
 * Pop the latest value off the given stack.
 *
 * @param s The stack to use.
 * @return  The latest value pushed into the stack.
 */
def pop(s) = { _v = s._values--; _v ? _v[-1] : null }

/*
 * Is the given stack empty?
 *
 * @param s The stack to check on.
 * @return  Whether or not the stack is empty.
 */
def isempty(s) = { !s._values }

/*
 * Peek at the top value on the stack without popping it.
 *
 * @param s The stack to use.
 * @return   The top-most element of the stack, without modifying the stack.
 */
def peek(s) = { s._values ? s._values[-1] : null }

/*
 * Construct a nice string form of the version information.
 */
def versionstring = `Version ${info.version.major}.${info.version.minor}.${info.version.patch} build ${substr(info.version.build, 1)}${info.version.prerelease}`

/*
 * Execute the "uuid" program to return a unique identifier.
 *
 * @return A unique identifier.
 */
define uuid() = {  trim(exec('uuid')) }

/*
 * Execute the "sleep" program for the given time period.
 *
 * @param time A time period to sleep (could be "n" seconds, or other units such as "2m").
 */
define sleep(time) = { trim(exec('sleep', time)) }

/*
 * Hash a file using the given algorithm (default is "SHA-256" if none given).
 *
 * @param filename  Name of the file to compute the hash for.
 * @param algorithm Which hash algorithm to use.
 * @param uppercase Which case to use for the result (default 'false')
 * @return          The given hash value (lower case).
 */
define hash(filename, algorithm = 'sha-256', uppercase = false) = {
   trim(exec('hsh', uppercase ? '--upper' : '--lower', '--algorithm=' + algorithm, '--file', filename))
}

/*
 * Hash a string with same parameters as "hash".
 *
 * @param value     The string value to hash.
 * @param algorithm Which hash algorithm to use.
 * @param uppercase Which case to use for the results (default 'false')
 * @return          The given string's hash value.
 */
define hashstring(value, algorithm = 'sha-256', uppercase = false) = {
   trim(exec('hsh', '--line', uppercase ? '--upper' : '--lower', '--algorithm=' + algorithm, `${value@q}`))
}

/*
 * Compute the mean and standard deviation of a list of values.
 *
 * @param values
 * @return { mean: xxx, stddev: sss }
 */
define mean_stddev (values) = {
  len = length(values)
  avg = sumof(values) / len
  variance = 0
  loop v over values { variance += (v - avg) ** 2 }
  variance /= len
  { mean: avg, stddev: round(sqrt(variance), 3) }
}

