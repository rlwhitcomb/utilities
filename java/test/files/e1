/*
 * Tests of the expression engine in Calc.
 */
:echo "Starting expression tests (suite 1)."
:echo

# Simple version check ...
# version 2.3.0 was first version where these checks would work, and 2.4.11 is where versioninfo -> info.version
info.version.major > 2 || (info.version.major == 2 && info.version.minor > 4) || (info.version.major == 2 && info.version.minor == 4 && info.version.patch >= 11)
:requires '2.12.5-alpha', base '1.9.15-alpha'

# Various simple expressions
:decimal(50)
52+27
3.4 + 5
34 + 5 @x

pi
phi
Φ
1/phi == PHI
1/PHI == phi
PHI+1 == phi
:rational on
phi
PHI
phi@d
:rational off

sin(pi/3)
4 & 7
true && false
(1+2) * (3+4)
:Double
atan2(4, 5)
14/7;12/4;13/9
a = 1; b = 2; a+b;
a<=>b; a<=b; b<a; 1>2; 2>=1;
:DEFAULT
1.2+3.4
1/7
settings.precision
:decimal 18
settings.precision
e
a
:clear
a
a = b = c = 27; a+b; b+c
e

# Now some string tests
name = 'Roger'
"This isn't a number"
'This ' + "isn't" + " a number"
'This isn\'t either, ' + name
'\u0000\u0001\u0002\u0003\u0004\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f\u0020\u0021'
'\0\ca\cB\cy\cZ\f\t\b\r\n\\\u007f\u0080\u0081'

# Other operators and functions
:decimal 60
s = sqrt(17);
t = s * s;
t = 17**0.5
t * t
u = 12!
v = cbrt(u)
v*v*v-u
u**(1/3)
t⁸
3⁶

_This_is_a_very_long_variable_name_Which_not_surprisingly_is_not_worth_remembering_1_ = sqrt 42
++ _This_is_a_very_long_variable_name_Which_not_surprisingly_is_not_worth_remembering_1_

:clear [ _This_is_a_very_long_variable_name_Which_not_surprisingly_is_not_worth_remembering_1_ ]
_This_is_a_very_long_variable_name_Which_not_surprisingly_is_not_worth_remembering_1_

# Factorial tests
72!
-5!
-8!
1/7!

# Special tests of the "fib" function
fib 27
fib 0
fib 1
fib 2
fib 3
fib 5
fib -1
fib -2
fib -6
fib 200
oldPrec = settings.precision
settings.precision = 100
sum = 0
:quiet on { loop f over 100..200 { sum += fib(f) } }
sum
:dec oldPrec

# Trig and log functions
J = 1; ++J; J;
K = 2; K++; K;
:double
pi / 2
asin ( sin ( pi / 2 ) )
pi/4
acos(cos(pi/4))
pi/3
atan(tan(pi/3))
b = -27; c = 0; d = 153;
signum b; signum c; signum d;
length b; length c; length d;
scale b; scale c; scale d;
h = 23
h2 = ln(h)
e**h2
epow(h2)
m = 10000
n = log(m)
10**n
tenpow(n)
p = ln2(1000000)
2**p
isprime 15485863

isnull junk
notnull junk
notnull h2
j2=nil
isnull j2
notnull j2
notnull n
j3=␀
isnull j3
notnull j3
NotNull p

upper typeof p
g1 = 'A strong message'
upper g1
lower g1
g2=['abc', 'Def', "gHI"]; upper(g2); lower g2
g3 = { b: 'This', c: 'is', d: 'crazy' }; upper(g3); lower(g3)
:ignore on { upper g3; lower g3 }
g4 = { b: "abc", c: [ "an", "Upper", "way" ], d: { c: "over", f: "One" } }
upper g4
:ignore on { upper g4 }

typeof "abc"
typeof null
typeof PHI
typeof(1.2)
:rational on
typeof(½)
:rational pop
typeof(tenpow(5))
typeof(false)
typeof(info)
typeof(info.locale.weekdays)
# Note: these will both be "integer" for now, until we figure out how to differentiate them
typeof(D'9/11/2001')
typeof(now)
def junk_func = { 'junk' }
typeof(junk_func)
typeof(junk_func())

cast(null)
cast(1, 'string')
cast("23", 'float')
cast("true", 'boolean')
cast(10**n)
cast(1, 'array')
cast("abc", 'object')
cast(3, 'null')
cast([1,2,3], 'array')
cast({ a:'123' }, 'object')
cast(null, 'object')
:clr junk
junk=[1,2,3]
cast(junk[0], 'function')
typeof(_junk5b05d)
:var _junk5b05d

settings.trigMode
:degrees
settings.trigMode

sin(45)
cos(60)
asin(sin(50))
acos(cos(30))
atan(tan(15))

:rad
settings.trigMode
:dec 60
π
a = sin(π/4)
b = a * 2
c = b*b
round c, 14
round(a, 10)
round a, -2
round c, 0

v = 1621.9

:resultonly on
loop -10 .. 10 { `round to $__ -> ${round(v, __)}` }
random(123)
loop over 20 { random }
:resultonly pop

sin(2700)
sin -(4*pi)

# Min, max, gcd, and lcm tests
min 1, -1, 27, -300, 18.5, -300.5
max 'abc', 'ghi', "ABC", "012"

min(-27)
max(2.4)
min(-3,-5)
max(1,3,5,2,8,9,11,4,6)

gcd(25, 10)
gcd(27*2, 3*9*18)

lcm(6, 10)
lcm -20, 30

max('123', 456, 789)
min(123, '-1', '14')

# Integer division
ty=47
ty\13
ty\=6
10\3
5\6

# Bit and logical operators
127 | 128
15 & 7
31 ^ 10

0b0011 ~& 0b0101 @b
0b0011 ~| 0b0101 @b
0b0011  ^ 0b0101 @b
~0b0110 @b
0b0011 ~^ 0b0101 @b
0x3FF &~ 0xFF0 @X

'abc' != "ABC" && 0 <> 1

false ^^ false
false ^^ true
true ^^ false
true ^^ true

A=1;B=2
A==1||A==2&&B==1
A==1&&A==2||B==1

0xFFFF ^ 0xAAAA @X
012
10 @o
0b1010101010 @x
0x2aa @b
~ 0x7FFF @X
~ 0x7FFF @o
~ 0x7FFF @b
255 @o
123 @b
:quotestrings off {
f1 = `${'def' @o}`
f2 = `${'abc' @b}`
f3 = `${'Hello' @X}`
}
eval f1;eval f2;eval f3

t1=5.9
t2=-6.2
ceil(t1);ceil(t2)
ceil(0);ceil(10e22)
floor(t1);floor(t2)
floor(0);floor(1.2e9)

# The "join" operator
:clear this, hello, handsome, rude
this = join('This', 'is', 'a', 'test', ' ');
hello = join('Hello', "World!", ', ');
handsome = join("Hello ", "handsome.");
rude = join "RUDE!"
length this; length hello; length handsome; length rude;

'[' + join (1, 2, 3, 4, 5, ', ') + ']'

# The "split" function
target = 'this is the day'
split target, ' '
split(target,' ',2)
target = 'boo:and:foo'
split target, ':', 2
split(target, ':', 5)
split(target, ':', -2)
split(target, 'o', 5)
split(target, 'o', -2)
split target, 'o'
split 1.2, '\\.'
c9 = " a   b d   c   e   f "
:echo `pieces = ${split(trim(c9), '\\s+') @Q}`

# The "index" operator
:clear target, one, two, three
target = 'This is an "index" test.'
one = index target, 'is'
two = index target, 'is', one+1
three = index target, 'test', -1
index(target, 'junk')
index(target, 'more junk', -1)
index 1.2, '2'
st2 = 'abcdefg'
loop j within length(st2) { index(st2, st2[j], -1) + length(st2) == j }
ar2 = [ 1, 2, 3, 4 ]
loop j within length(ar2) { index(ar2, ar2[j], -1) + length(ar2) == j }
ob2 = { o1: 2, o2: 'off', o3: false }
loop j over ob2 { index(ob2, j, -1) + length(ob2) }
ob2['o2']
ob2[2]
length(ob2)
loop within length(ob2) { ob2[__] }
loop j over ob2 { ob2[j] }
loop key over ob2 { index(ob2, key) }

t8 = [ 2, 3, 5, 7, 11, 13, 17, 19, 21, 23, 29, 31 ]
notnull(index(t8, 22-1, -1))

# The "substr" operator
one = substr(target, 4)
two = substr(target, 11, 18)
three = substr(target, index(target, 'test', -1))
substr(target, index(target, '"', 0), index(target, '"', -1) + 1)
substr 1.234, 1, 3
substr(target, -1, -3)

# The "replace" function in all of its options
tl = 'tell teal tail teel toil tool toll'
replace(tl, 't(..)l', 't$1b', all)
replace tl, 't..l', 'test', first
replace tl, 't..l', 'test', last
replace tl, 't', 'b'
r1 = [ 'tell', 'teal', 'tail', 'teel', 'toil', 'tool', 'toll' ]
replace(r1, 't(..)l', "t$1b", all)

# Make sure the option keywords still work as variable names
all = 1; first = 2; last=7; all+first-last
on = true; off ='OFF'; prev = 12; previous = 15; yes = 'really'; no = 'fat chance'; pop = 27
on; off; prev; previous; yes; no; pop

# Slice function
n = [ 1, 2, 3, 4, 5 ]
slice n, 2, -1
slice(target, -5)

# Splice function
s1 = [ 1, 2, 3 ]
splice(s1, 1, 0, 5, 6)
s1
s2 = [ "This", "is", "a", "test" ]
splice s2, 2, 1, "an", "important", "little"
s2
s3 = { a:1, b:true, c:'tree', d:14 }
splice s3, [ b, c ], { f: 'def', g: 'green' }
s3

# Trim functions
funny_string = ' \t\f  \r\n   345  \f  \t \r\n  '
trim funny_string
ltrim funny_string
rtrim funny_string
trim (1.2 + " ")
t1 = [ " abc", " def  ", "ghi   " ]
t2 = { a: "  a b c ", b: '   def', c: 'ghi   ', d: t1 }
trim t1; ltrim t1; rtrim t1
trim t2; ltrim t2; rtrim t2

# The "fill" function
arr_n = []
fill arr_n, 0, 10
fill arr_n, 1, 2, 3
fill arr_n, 3, 12, 4

str_b = ''
fill(str_b, '=', 25)
fill(str_b, '-', 0, 3)
fill(str_b, '-', 22, 3)

# Tiny tests of "formatstring"
formatstring('%1$s, %2$s!', 'Hello', 'World')
formatstring("Rate is %1$8.6f", 12.34567)
formatstring('Name: %1$-20s, Age: %2$5d', 'Agnes Brown', 97)
formatstring("%02d", yod(d'2022-05-20') % 100)

# The "pad" functions
arr_m = [ 10 ]
pad(arr_m, 10, -1)
lpad(arr_m, 15, -2)
rpad(arr_m, 17, 20)
pad(arr_m, 23)
arr_m

str_c = '#'
rpad(str_c, 9, '>')
lpad(str_c, 18, '<')
pad(str_c, 24, '_')
pad(str_c, 30)
str_c

# The "reverse" function
palin = 'Was it a car or a cat I saw'
reverse(palin)
arr_m = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
reverse arr_m
arr_m

# The "unique" function
u1 = "aaabbaacceeeffccdd"
unique u1
u2 = chars u1
unique u2

# The "sort" function
a1 = [ 4, 3, 1, 2, -1, 5, -10 ]
a2 = [ "abc", "Abc", "aBc", "abC" ]
a3 = [ "abc", "DEF", "Abc", "def", "1.1.0", "1.10.0", "1.2.0" ]
a4 = [ { b: 20}, {b: 10}, {b:0}, {b:1}, {b:100}, {b:-1} ]
a1 = sort a1
a1
sort(a2)
a2
sort(a2, true)
sort a3
sort a3, true
sort a3, false
sort a4

# Precedence of compare / equal operators
1 < 2 == 3 > 4
1 == '1' > 2 != '2'

# Special tests of the strict equality vs. equality operations
1 === '1'
1 == '1'

! true
a
! (a == null)

# "to boolean" operator
!! null
!! ''
!! 0
!! 1
!! 'abc'

# "to number" operator
~~false
~~true
~~'1'
~~'1.234'
~~('1'+'2')
~~(1/2)

# JavaScript compatible string -> boolean operations

!foundset.username
foundset.username=''
!foundset.username
foundset.username='Don'
!foundset.username
!!foundset.username

# Testing operations a various precisions
:decimal 200; 1/7
:decimal 30; 1/9
:decimal 50; pi
:decimal 10000; e

# The formatting operations
:binary
1024**2@k
:ten
1000**4@k
:mixed
1024**3@k

100MB
2EB
2EiB
900KB@k
300PB
450PiB

10! @w
500 + 40 + 7 @W

0.125@2%
0.1234567@4%

20! + 0.5@2,$
1500@$

'abc'@+20s
'def'@-20s
'ghi'@20s

:echo

# Rational mode pre/post inc/dec
:rational true
fr1 = 5/6
++fr1
--fr1
fr2 = 15/7
fr2++
fr2--
fr2--
fr2@F

:rational pop

//
// Now, start on the array and object stuff
//
a = [1, 2, 3]
a[0] = 4
a[1] = 5
a
a[3] = 10
a
a₀
a₂
length a; scale a;

b = null
b[2] = 'abc'
b
b[0] = 'ABC'
b

c = null
c.d = true
c.f = 1.2
c.g = "Begin"
c."key" = 'end'
c
length c; scale c;

d = [ 1, { start:1, end: 2 }, { px:0, py:0}, "Area" ]
d
d[0] = 2; d[1].start = 3; d[2].py = 4; d[3] = "Bounding " + d[3];
d@j
length d; scale d;

f = { coords: [1, 1, 4, 5], name: "box" }
f@0.4j

# The ternary operator
1 == 2 ? 'impossible' : 'correct'
2! < 2**2 ? 'true' : 'not likely'
x = 7; y = 8
_min = min_plus_1 = x < y ? x + 1 : y + 1
_min

null ?: 'nothing'
'' ?: 'empty'
'a' ?: 'no a'
0 ?: 1
true ?: 'not true'

desc = 'heading'
desc ?! `${desc @20s}`
'' ?! 'funny'
true ?! 'TRUTH'
false ?! 'oops! true'

y = x = 7 + 1
y; x;

:clear m
m[0] = m[1] = m[2] = 3;
m
:clear n
n.a = 'First'; n.b = 123; n.c = false;
n

# Interpolated strings
:clear a
a = 128
` a is $a, b isn't $a`
`a + 1 = ${a + 1}`
`5! = ${5!} !!`
`g$$`
`a = ${a@x}`
`a = ${a@%}`
`a = ${a@k}`

# The various assignment operators
:clr [g,h,j,k]
:dec(200)
g = 271; h = 385; j = 192; k = 120!
g+=h
j-=g
h*=g
j/=g
k %= 10**40;
k
g = 0377@o; g&=0177@o
h = 0x400@x; h|=0x080@o
j = 0xaaa@x; j^=0x554@x
g@o; h@x; j@x;
g = 0x4000@x
g >>>= 3@x
g >>= 2@x
g<<=2@x
g@x

# Operations on parts of arrays and objects
a = { b : [ 1, 2, 3 ], c : { d: 1, f: true, g: 'abcd' } } 
a
++a.b[1]
a.b
a.c.d++
a
a.c.d++
a
a.b[2] = a.b[0] + a.c.d
a
a.c.h = a.c.g + ": " + `a.b[2] = ${a.b[2]}`
a@4j
length a; scale a.b;

r = ∅; s = ⦰
length r; length s
r == s

format = 'abcdefg'
format[1] = 'z'
format[2] = 'y'
format[3] = 'xw'
format[8] = 'new'
format

b = [ [ [ 1,2], [3,4], [5, 6]]]
b[0][0][1] = 11
b[1] = [ [ 7,9], [0,1], [3,4] ]
b@-j
length b; scale b; length b[1];

:def
p = {b:2, c: { d:true }, "e":e }
p@j
length p; scale p;
:echo "Elements of p:"
:result on
loop _p ∈ p { `name: $_p, value: ${p[_p]}` }
:result pop

#
# "CHARS" and "CODES" functions
#
codes 'abc'
chars 'abc'
codes 123
chars 123
loop codes(123) __
loop chars(123) {__}
loop codes "⅛34" __
loop chars "⅛34" {__}

#
# Fractions
#
:rational on
4/5 < 7/9
1/3 * 4/5@F
(7/11) / (9/5)
"5 3/8" * "4 1/4"@F
(4/6)⁹
u = 1/2
u **= -2
u**=-2
u**= -2
u**=-2
frac u

#
# Bernoulli numbers
#
bn 0
bn 1
bn -1
bn 2
bn 20
bn 126
:rational pop

#
# Tests of functions
#
:clear a
def a={ loop i in 10 { i }}
a
eval a

#
# Tests of Roman Numerals
#
r = R'MCMLXII'
s = r'ⅿⅽⅿⅼⅹⅶ'

1962 @R

roman('xx' + 'ii')

#
# Time and duration constants, expressions, and formats
#
t'27h' + t'13m' + t'27.9s' @h
h'12:30 pm' - h'11:45 am' @mt
h'8:30 am' + t'1h' + t'37m' @h
t'3.0002s' @5mt
h'12:10am' - t'20m' @ah

#
# Date calculations
#
d'990101' - d'980101'
d'21/5/16' - d'99/12/31'
d'1941/12/7' + 1000@e
d'-01000101'
-756052@e
d'990101'
10592@e
d'000101'@e
d'500101'@e
d'49/01/01'@e
d'-9999/01/01'@e
D'01-01--9999'@E
d'9999/12/31'@e
d911 = D'9/11/01'
d911@e;d911@E
D'1/1/1999'@e
_waterloo = d'1815/6/18'
_waterloo@e;_waterloo@E



#
# Play around with "," formatting
#
pi**20@,d
pi@,d
200!@,d
10e-9@,d
nanosperday=24*60*60*1e9@,d

:sep on
nanosperday
:clear m
n = [ 1e10, 2<<15, 42! ]
m = { p:15!, q:3**12, r:pi**15, s:n }
`1^10 = ${1e10}`
:sep pop

#
# New Unicode math symbols
#
➖2
t=10
➖➖t
➕3
➕➕t
t➖➖
t➕➕
t➖3
t➕3
t➗4
t✖5
t✕3
t∗2
t÷3
t∕4

#
# New Unicode number symbols
#
０
①
⓯
𝟦
⑳
⒇
⒚

#
# Base64 encode/decode
#
encode ('This is a Base64 test.')
decode "VGhpcyBpcyBhIEJhc2U2NCB0ZXN0Lg=="
arr1 = [1,2,3]
enc1 = encode arr1
arr2 = eval(decode enc1)
arr1 === arr2
p1 = encode pi
p2 = eval(decode p1)
pi === p2

#
# "const" declarations
#
const two_pi = 2*pi
sin(two_pi)
two_pi/pi

#
# "matches" function
#
input_string = 'This is the day'
matches(input_string, '.+is is.+')
matches(input_string, '^.+day$')
matches(input_string, '.*way')
input_array = ["ab", "aba", "baa", "cab", "dab", "ghi", "jkl", "abab"]
matches(input_array, '.*ab.*')
input_object = [
  { fname: 'John', mname: 'L', lname: 'Smith', addr1: '123 Main St', addr2: '', city: 'Anytown', state: 'OH' },
  { fname: 'Mary', mname: 'S', lname: 'Jones', addr1: '1515 Elm Ave', addr2: '', city: 'Maytown', state: 'MD' },
  { fname: 'Cecile', mname: 'R', lname: 'Mayshawn', addr1: '14235 Sierra Rd', addr2: 'Rte 17 Box 12', city: 'Rural', state: 'OR' }
]
matches(input_object, '.+name')@j

#
# Defining functions inside blocks
#
:default
loop j over settings.precision {
  define help(n) = 10 ** -n
  :decimal j
  help(j)
}

define Truth(v) = {
  if v "T" else "F"
}

Truth({})
Truth("")
Truth([])
Truth({ d: false })
Truth([ 45 ])
Truth(null)
Truth("a")
Truth("false")
Truth(settings)

:echo
:echo "End of expression tests (suite 1)."

